import {
  pascalCase
} from "./chunk-YOXE2NTL.js";
import {
  addProductReview,
  addProductToCart,
  addPromotionCode,
  addWishlistProduct,
  cancelOrder,
  changeCartItemQuantity,
  changeOrderPaymentMethod,
  createCustomerAddress,
  createOrder,
  deleteCustomerAddress,
  getAvailableCountries,
  getAvailablePaymentMethods,
  getAvailableSalutations,
  getAvailableShippingMethods,
  getCart,
  getCategoryDetailsEndpoint,
  getCategoryProducts,
  getCustomer,
  getCustomerAddresses,
  getCustomerOrders,
  getDocumentDownload,
  getLandingPage,
  getOrderDetails,
  getOrderDownloads,
  getProduct,
  getProductDetailsEndpoint,
  getProductEndpoint,
  getProductReviews,
  getProducts,
  getSeoUrl,
  getSessionContext,
  getStoreNavigation,
  getUserCountry,
  getUserSalutation,
  getWishlistProducts,
  handlePayment,
  invokeGet,
  invokePost,
  isNewsletterSubscriber,
  login,
  logout,
  mergeWishlistProducts,
  newsletterSubscribe,
  newsletterUnsubscribe,
  register,
  removeCartItem,
  removeWishlistProduct,
  resetPassword,
  searchProducts,
  setCurrentBillingAddress,
  setCurrentCurrency,
  setCurrentLanguage,
  setCurrentPaymentMethod,
  setCurrentShippingAddress,
  setCurrentShippingMethod,
  setDefaultCustomerBillingAddress,
  setDefaultCustomerPaymentMethod,
  setDefaultCustomerShippingAddress,
  updateCustomerAddress,
  updateEmail,
  updatePassword,
  updateProfile
} from "./chunk-JGMX3SKF.js";
import {
  computed,
  effectScope,
  inject,
  markRaw,
  onMounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  unref
} from "./chunk-LGAZO65B.js";
import {
  getListingFilters,
  getMainImageUrl,
  getProductTierPrices,
  getSrcSetForMedia,
  getTranslatedProperty
} from "./chunk-NRQQV2U4.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@shopware-pwa/composables-next/dist/index.mjs
import { createSharedComposable, syncRefs } from "@vueuse/core";
var PRODUCT_ROUTE_NAME = "frontend.detail.page";
var CATEGORY_ROUTE_NAME = "frontend.navigation.page";
var LANDING_PAGE_ROUTE_NAME = "frontend.landing.page";
function useCmsElementImage(element) {
  const { getConfigValue } = useCmsElementConfig(element);
  const containerStyle = computed(() => ({
    minHeight: getConfigValue("minHeight")
  }));
  const anchorAttrs = computed(() => ({
    href: getConfigValue("url"),
    target: getConfigValue("newTab") ? "_blank" : "_self"
  }));
  const imageLink = computed(() => {
    var _a, _b;
    return {
      newTab: (_a = element.data) == null ? void 0 : _a.newTab,
      url: (_b = element.data) == null ? void 0 : _b.url
    };
  });
  const imageContainerAttrs = computed(() => {
    const attr = {};
    if (imageLink.value.url) {
      attr.href = imageLink.value.url;
    }
    if (imageLink.value.newTab) {
      attr.target = "blank";
      attr.rel = "noopener noreferrer";
    }
    return attr;
  });
  const imageAttrs = computed(() => {
    var _a, _b, _c, _d, _e;
    return {
      src: (_b = (_a = element.data) == null ? void 0 : _a.media) == null ? void 0 : _b.url,
      alt: ((_d = (_c = element.data) == null ? void 0 : _c.media) == null ? void 0 : _d.alt) || "",
      srcset: getSrcSetForMedia((_e = element.data) == null ? void 0 : _e.media)
    };
  });
  const displayMode = computed(
    () => getConfigValue("displayMode") || "initial"
  );
  return {
    containerStyle,
    anchorAttrs,
    imageAttrs,
    imageContainerAttrs,
    imageLink,
    displayMode
  };
}
function useCmsElementConfig(element) {
  const getConfigValue = (key) => {
    var _a, _b;
    return ((_a = element.config[key]) == null ? void 0 : _a.source) !== "mapped" && ((_b = element.config[key]) == null ? void 0 : _b.value);
  };
  return {
    getConfigValue
  };
}
var ContextError = class extends Error {
  constructor(scope, message) {
    super(`${scope} ${message ? message : "context is not provided"}`);
    this.name = "ContextError";
  }
};
function useShopwareContext() {
  const shopwareContext = inject("shopware", null);
  if (!shopwareContext)
    throw new ContextError("Shopware");
  return {
    apiInstance: shopwareContext.apiInstance
  };
}
function _useContext(injectionName, params) {
  const isNewContext = !!(params == null ? void 0 : params.context);
  const _context = isNewContext ? ref(unref(params == null ? void 0 : params.context)) : inject(injectionName, ref());
  provide(injectionName, _context);
  if (!!(params == null ? void 0 : params.replace)) {
    _context.value = unref(params.replace);
  }
  return _context;
}
function useCategory(category) {
  const _category = _useContext("category", { context: category });
  if (!_category.value) {
    throw new ContextError("Category");
  }
  return {
    category: computed(() => _category.value)
  };
}
var cmsAssociations = {
  associations: {
    media: {},
    cmsPage: {
      associations: {
        sections: {
          associations: {
            blocks: {
              associations: {
                slots: {
                  associations: {
                    block: {
                      associations: {
                        slots: {
                          associations: {}
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
function useCategorySearch() {
  const { apiInstance } = useShopwareContext();
  async function search(categoryId, options) {
    const associations = (options == null ? void 0 : options.withCmsAssociations) ? cmsAssociations : {};
    const result = await invokePost(
      {
        address: getCategoryDetailsEndpoint(categoryId),
        payload: { associations, ...options == null ? void 0 : options.query }
      },
      apiInstance
    );
    return result.data;
  }
  return {
    search
  };
}
function useProductConfigurator() {
  var _a, _b;
  const { apiInstance } = useShopwareContext();
  const { configurator, product } = useProduct();
  if (!product.value) {
    throw new Error(
      "Product configurator cannot be used without the product context."
    );
  }
  const selected = ref({});
  const isLoadingOptions = ref(!!((_a = product.value.options) == null ? void 0 : _a.length));
  const parentProductId = computed(() => {
    var _a2;
    return (_a2 = product.value) == null ? void 0 : _a2.parentId;
  });
  const getOptionGroups = computed(() => {
    return configurator.value || [];
  });
  const findGroupCodeForOption = (optionId) => {
    const group = getOptionGroups.value.find((optionGroup) => {
      var _a2;
      const optionFound = (_a2 = optionGroup.options) == null ? void 0 : _a2.find(
        (option) => option.id === optionId
      );
      return !!optionFound;
    });
    return getTranslatedProperty(group, "name");
  };
  (_b = product.value.optionIds) == null ? void 0 : _b.forEach((optionId) => {
    const optionGroupCode = findGroupCodeForOption(optionId);
    if (optionGroupCode) {
      selected.value[optionGroupCode] = optionId;
    }
  });
  async function findVariantForSelectedOptions(options) {
    var _a2, _b2;
    const filter = [
      {
        type: "equals",
        field: "parentId",
        value: parentProductId.value
      },
      ...Object.values(options || selected.value).map((id) => ({
        type: "equals",
        field: "optionIds",
        value: id
      }))
    ];
    try {
      if (apiInstance) {
        apiInstance.defaults.headers.common["sw-include-seo-urls"] = "true";
      }
      const response = await invokePost(
        {
          address: getProductEndpoint(),
          payload: {
            limit: 1,
            filter,
            includes: {
              product: ["id", "translated", "productNumber", "seoUrls"],
              seo_url: ["seoPathInfo"]
            },
            associations: {
              seoUrls: {}
            }
          }
        },
        apiInstance
      );
      return (_b2 = (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.elements) == null ? void 0 : _b2[0];
    } catch (e) {
      console.error("SwProductDetails:findVariantForSelectedOptions", e);
    }
  }
  const handleChange = async (group, option, onChangeHandled) => {
    selected.value = Object.assign({}, selected.value, {
      [group]: option
    });
    if (typeof onChangeHandled === "function") {
      await onChangeHandled();
    }
  };
  return {
    handleChange,
    findVariantForSelectedOptions,
    isLoadingOptions,
    getOptionGroups,
    getSelectedOptions: selected
  };
}
function useProductReviews(product) {
  const { apiInstance } = useShopwareContext();
  const productReviews = ref([]);
  const loadProductReviews = async (parameters = {}) => {
    const fetchedReviews = await getProductReviews(
      product.value.id,
      void 0,
      // Object.assign({}, getDefaults(), parameters),
      apiInstance
    );
    productReviews.value = fetchedReviews.elements ?? [];
  };
  const addReview = async (data) => {
    await addProductReview(product.value.id, data, apiInstance);
  };
  return {
    productReviews: computed(() => productReviews.value),
    loadProductReviews,
    addReview
  };
}
function useProductAssociations(product, options) {
  if (!product.value)
    throw new Error("[useProductAssociations]: Product is not provided.");
  const association = options.associationContext;
  const { apiInstance } = useShopwareContext();
  const isLoading = ref(false);
  const associations = ref([]);
  const loadAssociations = async (params) => {
    isLoading.value = true;
    const method = params.method || "get";
    try {
      if (method && method === "get") {
        const response2 = await invokeGet(
          {
            address: `${getProductDetailsEndpoint(
              product.value.id
            )}/${association}${params.searchParams || ""}`
          },
          apiInstance
        );
        associations.value = response2 == null ? void 0 : response2.data;
        return;
      }
      const response = await invokePost(
        {
          address: `${getProductDetailsEndpoint(
            product.value.id
          )}/${association}`,
          payload: (params == null ? void 0 : params.searchParams) || {}
        },
        apiInstance
      );
      associations.value = response == null ? void 0 : response.data;
    } catch (error) {
      console.error(
        "[useProductAssociations][loadAssociations][error]:",
        error
      );
    } finally {
      isLoading.value = false;
    }
  };
  return {
    isLoading: computed(() => isLoading.value),
    productAssociations: computed(() => associations.value || []),
    loadAssociations
  };
}
function useCmsBlock(content) {
  function getSlotContent(slotName) {
    return content.slots.find((slot) => slot.slot === slotName);
  }
  return {
    block: content,
    getSlotContent
  };
}
function useCmsSection(content) {
  function getPositionContent(position) {
    return content.blocks.filter(
      (block) => block.sectionPosition === position
    );
  }
  return {
    section: content,
    getPositionContent
  };
}
function useNavigation(params) {
  const type = (params == null ? void 0 : params.type) || "main-navigation";
  const { apiInstance } = useShopwareContext();
  const sharedElements = inject(
    `swNavigation-${type}`,
    ref([])
  );
  provide(`swNavigation-${type}`, sharedElements);
  const navigationElements = computed(() => sharedElements.value);
  async function loadNavigationElements({ depth }) {
    try {
      const navigationResponse = await getStoreNavigation(
        {
          requestActiveId: type,
          requestRootId: type,
          searchCriteria: {
            // includes: getIncludesConfig(),
            // associations: getAssociationsConfig(),
          },
          depth
        },
        apiInstance
      );
      sharedElements.value = navigationResponse || [];
      return sharedElements.value;
    } catch (e) {
      sharedElements.value = [];
      console.error("[useNavigation][loadNavigationElements]", e);
      return [];
    }
  }
  return {
    navigationElements,
    loadNavigationElements
  };
}
function useCartFunction() {
  const { apiInstance } = useShopwareContext();
  const _storeCart = _useContext("swCart");
  async function refreshCart(newCart) {
    if (newCart) {
      _storeCart.value = newCart;
      return newCart;
    }
    const result = await getCart(apiInstance);
    _storeCart.value = result;
    return result;
  }
  async function addProduct(params) {
    const addToCartResult = await addProductToCart(
      params.id,
      params.quantity,
      apiInstance
    );
    _storeCart.value = addToCartResult;
    return addToCartResult;
  }
  async function removeItem(lineItem) {
    const result = await removeCartItem(lineItem.id, apiInstance);
    _storeCart.value = result;
  }
  async function changeProductQuantity(params) {
    const result = await changeCartItemQuantity(
      params.id,
      params.quantity,
      apiInstance
    );
    _storeCart.value = result;
  }
  async function submitPromotionCode(promotionCode) {
    if (promotionCode) {
      const result = await addPromotionCode(promotionCode, apiInstance);
      _storeCart.value = result;
    }
  }
  async function getProductItemsSeoUrlsData() {
    if (!cartItems.value.length) {
      return [];
    }
    const result = await getProducts(
      {
        ids: cartItems.value.map(({ referencedId }) => referencedId).filter(String)
        // includes: (getDefaults() as any).getProductItemsSeoUrlsData.includes,
        // associations: (getDefaults() as any).getProductItemsSeoUrlsData
        //   .associations,
      },
      apiInstance
    );
    return (result == null ? void 0 : result.elements) || [];
  }
  const appliedPromotionCodes = computed(() => {
    return cartItems.value.filter(
      (cartItem) => cartItem.type === "promotion"
    );
  });
  const cart = computed(() => _storeCart.value);
  const cartItems = computed(() => {
    return cart.value ? cart.value.lineItems || [] : [];
  });
  const count = computed(() => {
    return cartItems.value.reduce(
      (accumulator, lineItem) => lineItem.type === "product" ? lineItem.quantity + accumulator : accumulator,
      0
    );
  });
  const isEmpty = computed(() => count.value <= 0);
  const totalPrice = computed(() => {
    const cartPrice = cart.value && cart.value.price && cart.value.price.totalPrice;
    return cartPrice || 0;
  });
  const shippingTotal = computed(() => {
    var _a, _b, _c, _d;
    const shippingTotal2 = (_d = (_c = (_b = (_a = cart.value) == null ? void 0 : _a.deliveries) == null ? void 0 : _b[0]) == null ? void 0 : _c.shippingCosts) == null ? void 0 : _d.totalPrice;
    return shippingTotal2 || 0;
  });
  const subtotal = computed(() => {
    var _a, _b;
    const cartPrice = (_b = (_a = cart.value) == null ? void 0 : _a.price) == null ? void 0 : _b.positionPrice;
    return cartPrice || 0;
  });
  const cartErrors = computed(
    () => {
      var _a;
      return ((_a = cart.value) == null ? void 0 : _a.errors) && Object.values(cart.value.errors) || [];
    }
  );
  const isVirtualCart = computed(() => {
    return cartItems.value.length > 0 && cartItems.value.filter((element) => element.type !== "promotion").every((item) => item.states.includes("is-download"));
  });
  return {
    addProduct,
    addPromotionCode: submitPromotionCode,
    appliedPromotionCodes,
    cart,
    cartItems,
    changeProductQuantity,
    count,
    refreshCart,
    removeItem,
    totalPrice,
    shippingTotal,
    subtotal,
    cartErrors,
    getProductItemsSeoUrlsData,
    isEmpty,
    isVirtualCart
  };
}
var useCart = createSharedComposable(useCartFunction);
function useCartItem(cartItem) {
  if (!cartItem) {
    throw new Error("[useCartItem] mandatory cartItem argument is missing.");
  }
  const { apiInstance } = useShopwareContext();
  const { refreshCart, changeProductQuantity } = useCart();
  const itemQuantity = computed(() => cartItem.value.quantity);
  const itemImageThumbnailUrl = computed(() => getMainImageUrl(cartItem.value));
  const itemRegularPrice = computed(
    () => {
      var _a, _b, _c, _d, _e;
      return ((_c = (_b = (_a = cartItem.value) == null ? void 0 : _a.price) == null ? void 0 : _b.listPrice) == null ? void 0 : _c.price) || ((_e = (_d = cartItem.value) == null ? void 0 : _d.price) == null ? void 0 : _e.unitPrice);
    }
  );
  const itemSpecialPrice = computed(
    () => {
      var _a, _b, _c, _d, _e;
      return ((_c = (_b = (_a = cartItem.value) == null ? void 0 : _a.price) == null ? void 0 : _b.listPrice) == null ? void 0 : _c.price) && ((_e = (_d = cartItem.value) == null ? void 0 : _d.price) == null ? void 0 : _e.unitPrice);
    }
  );
  const itemTotalPrice = computed(() => {
    var _a;
    return (_a = cartItem.value.price) == null ? void 0 : _a.totalPrice;
  });
  const itemOptions = computed(
    () => {
      var _a;
      return cartItem.value.type === "product" && ((_a = cartItem.value.payload) == null ? void 0 : _a.options) || [];
    }
  );
  const itemStock = computed(() => {
    var _a;
    return (_a = cartItem.value.deliveryInformation) == null ? void 0 : _a.stock;
  });
  const itemType = computed(() => cartItem.value.type);
  const isProduct = computed(() => cartItem.value.type === "product");
  const isPromotion = computed(() => cartItem.value.type === "promotion");
  async function removeItem() {
    const newCart = await removeCartItem(cartItem.value.id, apiInstance);
    await refreshCart(newCart);
  }
  async function changeItemQuantity(quantity) {
    await changeProductQuantity({
      id: cartItem.value.id,
      quantity
    });
  }
  async function getProductItemSeoUrlData() {
    if (!cartItem.value.referencedId) {
      return;
    }
    try {
      const result = await getProduct(
        cartItem.value.referencedId,
        {
          // includes: (getDefaults() as any).getProductItemsSeoUrlsData.includes,
          // associations: (getDefaults() as any).getProductItemsSeoUrlsData
          //   .associations,
        },
        apiInstance
      );
      return result.product;
    } catch (error) {
      console.error(
        "[useCart][getProductItemsSeoUrlsData]",
        error.messages
      );
    }
    return;
  }
  return {
    changeItemQuantity,
    removeItem,
    getProductItemSeoUrlData,
    itemRegularPrice,
    itemSpecialPrice,
    itemTotalPrice,
    itemOptions,
    itemStock,
    itemQuantity,
    itemType,
    itemImageThumbnailUrl,
    isProduct,
    isPromotion
  };
}
function useUser() {
  const { apiInstance } = useShopwareContext();
  const { userFromContext, refreshSessionContext } = useSessionContext();
  const _user = _useContext("customer");
  syncRefs(userFromContext, _user, {
    immediate: true
  });
  const { getStorefrontUrl } = useInternationalization();
  const { refreshCart } = useCart();
  const userDefaultPaymentMethod = computed(
    () => {
      var _a, _b;
      return ((_b = (_a = user.value) == null ? void 0 : _a.defaultPaymentMethod) == null ? void 0 : _b.translated) || null;
    }
  );
  const userDefaultBillingAddress = computed(
    () => {
      var _a;
      return ((_a = user.value) == null ? void 0 : _a.defaultBillingAddress) || null;
    }
  );
  const userDefaultShippingAddress = computed(
    () => {
      var _a;
      return ((_a = user.value) == null ? void 0 : _a.defaultShippingAddress) || null;
    }
  );
  const country = ref(null);
  const salutation = ref(null);
  const user = computed(() => _user.value);
  async function login$1({
    username,
    password
  } = {}) {
    await login({ username, password }, apiInstance);
    await refreshSessionContext();
    refreshCart();
  }
  async function register$1(params) {
    var _a;
    const customer = await register(
      { ...params, storefrontUrl: getStorefrontUrl() },
      apiInstance
    );
    _user.value = customer;
    if ((_a = _user.value) == null ? void 0 : _a.active)
      await refreshSessionContext();
    return customer;
  }
  async function logout$1() {
    await logout(apiInstance);
    await refreshSessionContext();
    refreshCart();
  }
  async function refreshUser(params = {}) {
    try {
      const user2 = await getCustomer(
        Object.assign(
          {},
          // getDefaults(),
          params
        ),
        apiInstance
      );
      _user.value = user2;
    } catch (e) {
      _user.value = void 0;
      console.error("[useUser][refreshUser]", e);
    }
  }
  async function loadCountry(userId) {
    country.value = await getUserCountry(userId, apiInstance);
  }
  async function loadSalutation(salutationId) {
    salutation.value = await getUserSalutation(salutationId, apiInstance);
  }
  async function updatePersonalInfo(personals) {
    await updateProfile(personals, apiInstance);
  }
  async function updateEmail$1(updateEmailData) {
    await updateEmail(updateEmailData, apiInstance);
  }
  async function setDefaultPaymentMethod(paymentMethodId) {
    await setDefaultCustomerPaymentMethod(paymentMethodId, apiInstance);
  }
  const defaultBillingAddressId = computed(
    () => {
      var _a;
      return ((_a = user.value) == null ? void 0 : _a.defaultBillingAddressId) || null;
    }
  );
  const defaultShippingAddressId = computed(
    () => {
      var _a;
      return ((_a = user.value) == null ? void 0 : _a.defaultShippingAddressId) || null;
    }
  );
  const isLoggedIn = computed(
    () => {
      var _a;
      return !!((_a = user.value) == null ? void 0 : _a.id) && !!user.value.active && !user.value.guest;
    }
  );
  const isCustomerSession = computed(
    () => {
      var _a;
      return !!((_a = user.value) == null ? void 0 : _a.id) && !user.value.guest;
    }
  );
  const isGuestSession = computed(() => {
    var _a;
    return !!((_a = user.value) == null ? void 0 : _a.guest);
  });
  return {
    login: login$1,
    register: register$1,
    user,
    isLoggedIn,
    isCustomerSession,
    isGuestSession,
    refreshUser,
    logout: logout$1,
    updateEmail: updateEmail$1,
    updatePersonalInfo,
    setDefaultPaymentMethod,
    loadSalutation,
    salutation,
    loadCountry,
    country,
    defaultBillingAddressId,
    defaultShippingAddressId,
    userDefaultPaymentMethod,
    userDefaultBillingAddress,
    userDefaultShippingAddress
  };
}
function _usePrice() {
  const currencyLocale = ref("");
  const currencyCode = ref("");
  function init(params) {
    _setCurrencyCode(params.currencyCode);
    _setLocaleCode(
      params.localeCode || typeof navigator !== "undefined" && (navigator == null ? void 0 : navigator.language) || "en-US"
    );
  }
  function _setCurrencyCode(code) {
    currencyCode.value = code;
  }
  function _setLocaleCode(locale) {
    currencyLocale.value = locale;
  }
  function getFormattedPrice(value) {
    if (typeof value === "undefined") {
      return "";
    }
    if (!currencyLocale.value) {
      return value.toString();
    }
    return new Intl.NumberFormat(currencyLocale.value, {
      style: "currency",
      currency: currencyCode.value
    }).format(+value);
  }
  return {
    init,
    getFormattedPrice
  };
}
var usePrice = createSharedComposable(_usePrice);
function useSessionContext(newContext) {
  var _a, _b, _c, _d;
  const { apiInstance } = useShopwareContext();
  const { init } = usePrice();
  if (newContext) {
    init({
      currencyCode: (_a = newContext.currency) == null ? void 0 : _a.isoCode,
      localeCode: (_d = (_c = (_b = newContext.salesChannel) == null ? void 0 : _b.language) == null ? void 0 : _c.locale) == null ? void 0 : _d.code
    });
  }
  const _sessionContext = _useContext("swSessionContext", {
    replace: newContext
  });
  const sessionContext = computed(() => _sessionContext.value);
  const refreshSessionContext = async () => {
    var _a2, _b2, _c2, _d2;
    try {
      const context = await getSessionContext(apiInstance);
      _sessionContext.value = context;
      init({
        currencyCode: (_a2 = context.currency) == null ? void 0 : _a2.isoCode,
        localeCode: (_d2 = (_c2 = (_b2 = context.salesChannel) == null ? void 0 : _b2.language) == null ? void 0 : _c2.locale) == null ? void 0 : _d2.code
      });
    } catch (e) {
      console.error("[UseSessionContext][refreshSessionContext]", e);
    }
  };
  const selectedShippingMethod = computed(
    () => {
      var _a2;
      return ((_a2 = sessionContext.value) == null ? void 0 : _a2.shippingMethod) || null;
    }
  );
  const setShippingMethod = async (shippingMethod = {}) => {
    if (!(shippingMethod == null ? void 0 : shippingMethod.id)) {
      throw new Error(
        "You need to provide shipping method id in order to set shipping method."
      );
    }
    await setCurrentShippingMethod(shippingMethod.id, apiInstance);
    await refreshSessionContext();
  };
  const selectedPaymentMethod = computed(
    () => {
      var _a2;
      return ((_a2 = sessionContext.value) == null ? void 0 : _a2.paymentMethod) || null;
    }
  );
  const setPaymentMethod = async (paymentMethod = {}) => {
    if (!(paymentMethod == null ? void 0 : paymentMethod.id)) {
      throw new Error(
        "You need to provide payment method id in order to set payment method."
      );
    }
    await setCurrentPaymentMethod(paymentMethod.id, apiInstance);
    await refreshSessionContext();
  };
  const currency = computed(() => {
    var _a2;
    return ((_a2 = sessionContext.value) == null ? void 0 : _a2.currency) || null;
  });
  const setCurrency = async (currency2 = {}) => {
    if (!currency2.id) {
      console.error(
        "You need to provide currency id in order to set currency.",
        currency2
      );
      return;
    }
    await setCurrentCurrency(currency2.id, apiInstance);
    await refreshSessionContext();
  };
  const setLanguage = async (language = {}) => {
    if (!language.id) {
      return;
    }
    await setCurrentLanguage(language.id, apiInstance);
    await refreshSessionContext();
  };
  const activeShippingAddress = computed(
    () => {
      var _a2, _b2;
      return ((_b2 = (_a2 = sessionContext.value) == null ? void 0 : _a2.customer) == null ? void 0 : _b2.activeShippingAddress) || null;
    }
  );
  const setActiveShippingAddress = async (address) => {
    if (!(address == null ? void 0 : address.id)) {
      throw new Error(
        "You need to provide address id in order to set the address."
      );
    }
    await setCurrentShippingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const activeBillingAddress = computed(
    () => {
      var _a2, _b2;
      return ((_b2 = (_a2 = sessionContext.value) == null ? void 0 : _a2.customer) == null ? void 0 : _b2.activeBillingAddress) || null;
    }
  );
  const setActiveBillingAddress = async (address) => {
    if (!(address == null ? void 0 : address.id)) {
      throw new Error(
        "You need to provide address id in order to set the address."
      );
    }
    await setCurrentBillingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const countryId = computed(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = sessionContext.value) == null ? void 0 : _a2.salesChannel) == null ? void 0 : _b2.countryId;
    }
  );
  const taxState = computed(() => {
    var _a2, _b2;
    return (_b2 = (_a2 = sessionContext.value) == null ? void 0 : _a2.context) == null ? void 0 : _b2.taxState;
  });
  const userFromContext = computed(() => {
    var _a2;
    return (_a2 = sessionContext.value) == null ? void 0 : _a2.customer;
  });
  return {
    sessionContext,
    refreshSessionContext,
    selectedShippingMethod,
    setShippingMethod,
    selectedPaymentMethod,
    setPaymentMethod,
    currency,
    setCurrency,
    activeShippingAddress,
    setActiveShippingAddress,
    activeBillingAddress,
    setActiveBillingAddress,
    countryId,
    taxState,
    userFromContext,
    setLanguage
  };
}
function useAddToCart(product) {
  const _product = computed(() => unref(product));
  const { addProduct, cartItems } = useCart();
  const quantity = ref(1);
  async function addToCart() {
    if (!quantity.value)
      quantity.value = 1;
    const addToCartResponse = await addProduct({
      id: _product.value.id,
      quantity: quantity.value
    });
    quantity.value = 1;
    return addToCartResponse;
  }
  const getStock = computed(() => {
    var _a;
    return (_a = _product.value) == null ? void 0 : _a.stock;
  });
  const getAvailableStock = computed(() => {
    var _a;
    return (_a = _product.value) == null ? void 0 : _a.availableStock;
  });
  const isInCart = computed(
    () => cartItems.value.some(
      (item) => {
        var _a;
        return item.referencedId === ((_a = _product.value) == null ? void 0 : _a.id);
      }
    )
  );
  return {
    addToCart,
    quantity,
    getStock,
    getAvailableStock,
    isInCart,
    count: computed(
      () => {
        var _a;
        return ((_a = cartItems.value.find(
          (item) => {
            var _a2;
            return item.referencedId === ((_a2 = _product.value) == null ? void 0 : _a2.id);
          }
        )) == null ? void 0 : _a.quantity) || 0;
      }
    )
  };
}
function useNotifications() {
  const _notifications = inject(
    "swNotifications",
    ref([])
  );
  provide("swNotifications", _notifications);
  function removeOne(notificationId) {
    var _a;
    _notifications.value = ((_a = _notifications.value) == null ? void 0 : _a.filter(({ id }) => id !== notificationId)) || [];
  }
  function removeAll() {
    _notifications.value = [];
  }
  function geterateId() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  async function pushNotification(message, options) {
    const timeout = options.timeout || 2500;
    const persistent = !!options.persistent;
    _notifications.value = _notifications.value || [];
    const messageId = geterateId();
    _notifications.value.push({
      id: messageId,
      type: options.type || "info",
      message
    });
    if (!persistent) {
      setTimeout(() => {
        removeOne(messageId);
      }, timeout);
    }
  }
  return {
    removeOne,
    removeAll,
    pushInfo: (message, options = {}) => pushNotification(message, { ...options, type: "info" }),
    pushSuccess: (message, options = {}) => pushNotification(message, { ...options, type: "success" }),
    pushWarning: (message, options = {}) => pushNotification(message, { ...options, type: "warning" }),
    pushError: (message, options = {}) => pushNotification(message, { ...options, type: "danger" }),
    notifications: computed(() => _notifications.value || [])
  };
}
function useLandingSearch() {
  const { apiInstance } = useShopwareContext();
  const search = async (navigationId, options) => {
    const associations = (options == null ? void 0 : options.withCmsAssociations) && cmsAssociations;
    const result = await getLandingPage(
      navigationId,
      associations || {},
      apiInstance
    );
    return result;
  };
  return {
    search
  };
}
function isObject$1(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function merge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (source === void 0) {
    return target;
  }
  if (isObject$1(target) && isObject$1(source)) {
    for (const key in source) {
      if (isObject$1(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        merge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return merge(target, ...sources);
}
function useListing(params) {
  var _a;
  const listingType = (params == null ? void 0 : params.listingType) || "categoryListing";
  const { apiInstance } = useShopwareContext();
  let searchMethod;
  if (listingType === "productSearchListing") {
    searchMethod = async (searchCriteria) => {
      return searchProducts(searchCriteria, apiInstance);
    };
  } else {
    let resourceId;
    try {
      const { category } = useCategory();
      resourceId = (_a = category.value) == null ? void 0 : _a.id;
    } catch (error) {
      if (error instanceof ContextError) {
        resourceId = params == null ? void 0 : params.categoryId;
      } else {
        console.error(error);
      }
    }
    searchMethod = async (searchCriteria) => {
      if (!resourceId) {
        throw new Error(
          "[useListing][search] Search category id does not exist."
        );
      }
      return getCategoryProducts(resourceId, searchCriteria, apiInstance);
    };
  }
  return createListingComposable({
    listingKey: listingType,
    searchMethod,
    searchDefaults: (params == null ? void 0 : params.defaultSearchCriteria) || {}
    //getDefaults(),
  });
}
function createListingComposable({
  searchMethod,
  searchDefaults,
  listingKey
}) {
  const loading = ref(false);
  const loadingMore = ref(false);
  const _storeInitialListing = inject(`useListingInitial-${listingKey}`, ref());
  provide(`useListingInitial-${listingKey}`, _storeInitialListing);
  const _storeAppliedListing = inject(`useListingApplied-${listingKey}`, ref());
  provide(`useListingApplied-${listingKey}`, _storeAppliedListing);
  const getInitialListing = computed(() => _storeInitialListing.value);
  const setInitialListing = async (initialListing) => {
    var _a, _b, _c, _d;
    if (((_b = (_a = initialListing == null ? void 0 : initialListing.currentFilters) == null ? void 0 : _a.manufacturer) == null ? void 0 : _b.length) || ((_d = (_c = initialListing == null ? void 0 : initialListing.currentFilters) == null ? void 0 : _c.properties) == null ? void 0 : _d.length)) {
      loading.value = true;
      const allFiltersResult = await searchMethod({
        query: initialListing.currentFilters.search || void 0
      });
      initialListing = Object.assign({}, initialListing, {
        aggregations: allFiltersResult == null ? void 0 : allFiltersResult.aggregations
      });
    }
    _storeInitialListing.value = initialListing;
    _storeAppliedListing.value = null;
    loading.value = false;
  };
  const initSearch = async (criteria) => {
    loading.value = true;
    try {
      const searchCriteria = merge({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      return result;
      await setInitialListing(result);
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  async function search(criteria, options) {
    loading.value = true;
    try {
      const searchCriteria = merge({}, searchDefaults, criteria);
      const [result, allFiltersResult] = await Promise.all([
        searchMethod(searchCriteria),
        searchMethod({
          query: searchCriteria.query,
          includes: { product_listing: ["aggregations"] }
        })
      ]);
      _storeAppliedListing.value = Object.assign({}, result, {
        aggregations: Object.assign(
          {},
          result == null ? void 0 : result.aggregations,
          allFiltersResult == null ? void 0 : allFiltersResult.aggregations
        )
      });
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  }
  const loadMore = async () => {
    var _a;
    loadingMore.value = true;
    try {
      const query = {
        // ...router.currentRoute.query,
        p: getCurrentPage.value + 1
      };
      const searchCriteria = merge({}, searchDefaults, query);
      const result = await searchMethod(searchCriteria);
      _storeAppliedListing.value = {
        ...getCurrentListing.value,
        page: result.page,
        elements: [
          ...((_a = getCurrentListing.value) == null ? void 0 : _a.elements) || [],
          ...result.elements
        ]
      };
    } catch (e) {
      throw e;
    } finally {
      loadingMore.value = false;
    }
  };
  const getCurrentListing = computed(() => {
    return _storeAppliedListing.value || getInitialListing.value;
  });
  const getElements = computed(() => {
    var _a;
    return ((_a = getCurrentListing.value) == null ? void 0 : _a.elements) || [];
  });
  const getTotal = computed(() => {
    var _a;
    return ((_a = getCurrentListing.value) == null ? void 0 : _a.total) || 0;
  });
  const getLimit = computed(() => {
    var _a;
    return ((_a = getCurrentListing.value) == null ? void 0 : _a.limit) || (searchDefaults == null ? void 0 : searchDefaults.limit) || 10;
  });
  const getTotalPagesCount = computed(
    () => Math.ceil(getTotal.value / getLimit.value)
  );
  const getSortingOrders = computed(() => {
    var _a, _b;
    const oldSortings = Object.values(((_a = getCurrentListing.value) == null ? void 0 : _a.sortings) || {});
    return ((_b = getCurrentListing.value) == null ? void 0 : _b.availableSortings) || oldSortings;
  });
  const getCurrentSortingOrder = computed(
    () => {
      var _a;
      return (_a = getCurrentListing.value) == null ? void 0 : _a.sorting;
    }
  );
  async function changeCurrentSortingOrder(order, query) {
    await search(
      Object.assign(
        {
          order
        },
        query || {}
      )
    );
  }
  const getCurrentPage = computed(() => {
    var _a;
    return ((_a = getCurrentListing.value) == null ? void 0 : _a.page) || 1;
  });
  const changeCurrentPage = async (page, query) => {
    await search(
      Object.assign(
        {
          p: page
        },
        query || {}
      )
    );
  };
  const getInitialFilters = computed(() => {
    var _a;
    return getListingFilters((_a = getInitialListing.value) == null ? void 0 : _a.aggregations);
  });
  const getAvailableFilters = computed(() => {
    var _a, _b;
    return getListingFilters(
      ((_a = _storeAppliedListing.value) == null ? void 0 : _a.aggregations) || ((_b = getCurrentListing.value) == null ? void 0 : _b.aggregations)
    );
  });
  const getCurrentFilters = computed(() => {
    var _a;
    const currentFiltersResult = [];
    const currentFilters = {
      ...(_a = getCurrentListing.value) == null ? void 0 : _a.currentFilters
      // ...router.currentRoute.query,
    };
    Object.keys(currentFilters).forEach((objectKey) => {
      if (!currentFilters[objectKey])
        return;
      if (objectKey === "navigationId")
        return;
      if (objectKey === "price") {
        if (currentFilters[objectKey].min)
          currentFiltersResult["min-price"] = currentFilters[objectKey].min;
        if (currentFilters[objectKey].max)
          currentFiltersResult["max-price"] = currentFilters[objectKey].max;
        return;
      }
      if (objectKey === "p")
        return;
      currentFiltersResult[objectKey] = currentFilters[objectKey];
    });
    return currentFiltersResult;
  });
  const setCurrentFilters = (filter) => {
    const appliedFilters = Object.assign({}, getCurrentFilters.value, filter, {
      query: getCurrentFilters.value.search
    });
    _storeAppliedListing.value.currentFilters = appliedFilters;
    return search(appliedFilters);
  };
  const resetFilters = () => {
    const defaultFilters = Object.assign(
      {
        manufacturer: [],
        properties: [],
        price: { min: 0, max: 0 },
        search: getCurrentFilters.value.search
      },
      searchDefaults
    );
    _storeAppliedListing.value.currentFilters = defaultFilters;
    return search({ query: getCurrentFilters.value.search });
  };
  const filtersToQuery = (filters) => {
    let queryObject = {};
    for (const filter in filters) {
      if (filters[filter]) {
        if (Array.isArray(filters[filter]) && filters[filter].length) {
          queryObject[filter] = filters[filter].join("|");
        } else if (!Array.isArray(filters[filter])) {
          queryObject[filter] = filters[filter];
        }
      }
    }
    return queryObject;
  };
  return {
    getInitialListing,
    setInitialListing,
    initSearch,
    search,
    getCurrentListing,
    getElements,
    getSortingOrders,
    getCurrentSortingOrder,
    changeCurrentSortingOrder,
    getCurrentPage,
    changeCurrentPage,
    getTotal,
    getTotalPagesCount,
    getLimit,
    getInitialFilters,
    getAvailableFilters,
    getCurrentFilters,
    setCurrentFilters,
    loading: computed(() => loading.value),
    loadMore,
    loadingMore: computed(() => loadingMore.value),
    resetFilters,
    filtersToQuery
  };
}
function useProduct(product, configurator) {
  const _product = _useContext("product", { context: product });
  if (!_product.value) {
    throw new ContextError("Product");
  }
  const _configurator = _useContext("configurator", {
    context: product && configurator
  });
  function changeVariant(variant) {
    _product.value = Object.assign({}, _product.value, variant);
  }
  return {
    product: computed(() => _product.value),
    configurator: computed(() => _configurator.value),
    changeVariant
  };
}
function isObject(object) {
  return object && typeof object === "object" && !Array.isArray(object);
}
function deepMerge(obj1, obj2) {
  const output = Object.assign({}, obj1);
  if (isObject(obj1) && isObject(obj2)) {
    Object.keys(obj2).forEach((key) => {
      if (isObject(obj2[key])) {
        if (!(key in obj1))
          Object.assign(output, { [key]: obj2[key] });
        else
          output[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        Object.assign(output, { [key]: obj2[key] });
      }
    });
  }
  return output;
}
function useProductSearch() {
  const { apiInstance } = useShopwareContext();
  const search = async (productId, options) => {
    const associations = deepMerge(
      (options == null ? void 0 : options.withCmsAssociations) ? cmsAssociations : {},
      options == null ? void 0 : options.criteria
    );
    const result = await getProduct(productId, associations, apiInstance);
    return result;
  };
  return {
    search
  };
}
var shippingMethodsAssociations = {
  associations: {
    prices: {}
  }
};
function useCheckout() {
  const { apiInstance } = useShopwareContext();
  const { refreshCart } = useCart();
  const {
    sessionContext,
    selectedPaymentMethod,
    selectedShippingMethod,
    setShippingMethod,
    setPaymentMethod
  } = useSessionContext();
  const storeShippingMethods = inject("swShippingMethods", ref());
  provide("swShippingMethods", storeShippingMethods);
  const storePaymentMethods = inject("swPaymentMethods", ref());
  provide("swPaymentMethods", storePaymentMethods);
  const shippingMethods = computed(() => storeShippingMethods.value || []);
  const paymentMethods = computed(() => storePaymentMethods.value || []);
  async function getShippingMethods({ forceReload } = { forceReload: false }, associations = {}) {
    if (shippingMethods.value.length && !forceReload)
      return shippingMethods;
    const mergedAssociations = deepMerge(
      shippingMethodsAssociations,
      associations
    );
    const response = await getAvailableShippingMethods(apiInstance, {
      ...mergedAssociations
    });
    storeShippingMethods.value = (response == null ? void 0 : response.elements) || [];
    return shippingMethods;
  }
  async function getPaymentMethods({ forceReload } = { forceReload: false }) {
    if (paymentMethods.value.length && !forceReload)
      return paymentMethods;
    const response = await getAvailablePaymentMethods(apiInstance, {
      onlyAvailable: true
      // depending on the context, some of them can be hidden due to applied rules describing whether a method can be available
    });
    storePaymentMethods.value = (response == null ? void 0 : response.elements) || [];
    return paymentMethods;
  }
  async function createOrder$1(params) {
    try {
      const order = await createOrder(params, apiInstance);
      return order;
    } catch (e) {
      const err = e;
      throw err;
    } finally {
      refreshCart();
    }
  }
  const shippingAddress = computed(
    () => {
      var _a, _b;
      return (_b = (_a = sessionContext.value) == null ? void 0 : _a.shippingLocation) == null ? void 0 : _b.address;
    }
  );
  const billingAddress = computed(
    () => {
      var _a, _b;
      return (_b = (_a = sessionContext.value) == null ? void 0 : _a.customer) == null ? void 0 : _b.activeBillingAddress;
    }
  );
  return {
    getPaymentMethods,
    paymentMethods,
    getShippingMethods,
    shippingMethods,
    createOrder: createOrder$1,
    shippingAddress,
    billingAddress,
    selectedShippingMethod,
    setShippingMethod,
    selectedPaymentMethod,
    setPaymentMethod
  };
}
function useSalutations() {
  const { apiInstance } = useShopwareContext();
  const _salutations = inject("swSalutations", ref());
  provide("swSalutations", _salutations);
  const error = ref(null);
  const fetchSalutations = async () => {
    try {
      const { elements } = await getAvailableSalutations(apiInstance);
      _salutations.value = elements;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  };
  const mountedCallback = async () => {
    if (!_salutations.value) {
      await fetchSalutations();
    }
  };
  const getSalutations = computed(() => {
    return _salutations.value || [];
  });
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchSalutations,
    getSalutations
  };
}
function useCountries() {
  const { apiInstance } = useShopwareContext();
  const _sharedCountried = inject("swCountries", ref());
  provide("swCountries", _sharedCountried);
  async function fetchCountries() {
    const { elements } = await getAvailableCountries(apiInstance);
    _sharedCountried.value = elements;
  }
  const getCountries = computed(() => {
    return _sharedCountried.value ?? [];
  });
  const mountedCallback = async () => {
    if (!_sharedCountried.value) {
      await fetchCountries();
    }
  };
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchCountries,
    getCountries
  };
}
var orderAssociations = {
  associations: {
    lineItems: {
      associations: {
        cover: {},
        downloads: {
          associations: {
            media: {}
          }
        }
      }
    },
    addresses: {},
    deliveries: {
      associations: {
        shippingMethod: {}
      }
    },
    transactions: {
      associations: {
        paymentMethod: {}
      },
      sort: "-createdAt"
    }
  }
};
function useOrderDetails(orderId, associations) {
  const { apiInstance } = useShopwareContext();
  const _sharedOrder = inject("swOrderDetails", ref());
  provide("swOrderDetails", _sharedOrder);
  const paymentMethod = computed(
    () => {
      var _a, _b, _c;
      return (_c = (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.transactions) == null ? void 0 : _b[0]) == null ? void 0 : _c.paymentMethod;
    }
  );
  const shippingMethod = computed(
    () => {
      var _a, _b, _c;
      return (_c = (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.deliveries) == null ? void 0 : _b[0]) == null ? void 0 : _c.shippingMethod;
    }
  );
  const paymentUrl = ref();
  const personalDetails = computed(() => {
    var _a, _b, _c, _d, _e, _f;
    return {
      email: (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.orderCustomer) == null ? void 0 : _b.email,
      firstName: (_d = (_c = _sharedOrder.value) == null ? void 0 : _c.orderCustomer) == null ? void 0 : _d.firstName,
      lastName: (_f = (_e = _sharedOrder.value) == null ? void 0 : _e.orderCustomer) == null ? void 0 : _f.lastName
    };
  });
  const billingAddress = computed(
    () => {
      var _a, _b;
      return (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.addresses) == null ? void 0 : _b.find(
        ({ id }) => id === _sharedOrder.value.billingAddressId
      );
    }
  );
  const shippingAddress = computed(
    () => {
      var _a, _b, _c;
      return (_c = (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.deliveries) == null ? void 0 : _b[0]) == null ? void 0 : _c.shippingOrderAddress;
    }
  );
  const shippingCosts = computed(() => {
    var _a;
    return (_a = _sharedOrder.value) == null ? void 0 : _a.shippingTotal;
  });
  const subtotal = computed(() => {
    var _a, _b;
    return (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.price) == null ? void 0 : _b.positionPrice;
  });
  const total = computed(() => {
    var _a, _b;
    return (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.price) == null ? void 0 : _b.totalPrice;
  });
  const status = computed(() => {
    var _a, _b;
    return (_b = (_a = _sharedOrder.value) == null ? void 0 : _a.stateMachineState) == null ? void 0 : _b.name;
  });
  async function loadOrderDetails() {
    const orderDetailsResponse = await getOrderDetails(
      orderId,
      deepMerge(orderAssociations, associations ? associations : {}),
      apiInstance
    );
    _sharedOrder.value = orderDetailsResponse ?? null;
  }
  async function handlePayment$1(finishUrl, errorUrl, paymentDetails) {
    const resp = await handlePayment(
      {
        orderId,
        finishUrl,
        errorUrl,
        paymentDetails
      },
      apiInstance
    );
    paymentUrl.value = resp == null ? void 0 : resp.redirectUrl;
  }
  async function cancel() {
    await cancelOrder(orderId, apiInstance);
    await loadOrderDetails();
  }
  async function changePaymentMethod(paymentMethodId) {
    await changeOrderPaymentMethod(orderId, paymentMethodId, apiInstance);
    await loadOrderDetails();
  }
  async function getMediaFile(downloadId) {
    const response = await getOrderDownloads(
      {
        orderId,
        downloadId
      },
      apiInstance
    );
    return response;
  }
  async function getDocumentFile(documentId, deepLinkCode) {
    const response = await getDocumentDownload(
      {
        documentId,
        deepLinkCode
      },
      apiInstance
    );
    return response;
  }
  const hasDocuments = computed(() => !!_sharedOrder.value.documents.length);
  const documents = computed(() => _sharedOrder.value.documents);
  return {
    order: computed(() => _sharedOrder.value),
    status,
    total,
    subtotal,
    shippingCosts,
    shippingAddress,
    billingAddress,
    personalDetails,
    paymentUrl,
    shippingMethod,
    paymentMethod,
    hasDocuments,
    documents,
    loadOrderDetails,
    handlePayment: handlePayment$1,
    cancel,
    changePaymentMethod,
    getMediaFile,
    getDocumentFile
  };
}
function useOrderPayment(order) {
  const { apiInstance } = useShopwareContext();
  const activeTransaction = computed(
    () => {
      var _a, _b;
      return (_b = (_a = order.value) == null ? void 0 : _a.transactions) == null ? void 0 : _b.find((t) => {
        var _a2;
        return ((_a2 = t.paymentMethod) == null ? void 0 : _a2.active) === true;
      });
    }
  );
  const paymentMethod = computed(() => {
    var _a;
    return (_a = activeTransaction.value) == null ? void 0 : _a.paymentMethod;
  });
  const paymentUrl = ref();
  const state = computed(() => {
    var _a;
    return (_a = activeTransaction.value) == null ? void 0 : _a.stateMachineState;
  });
  const isAsynchronous = computed(
    () => {
      var _a, _b, _c, _d;
      return ((_b = (_a = activeTransaction.value) == null ? void 0 : _a.paymentMethod) == null ? void 0 : _b.asynchronous) && ((_d = (_c = activeTransaction.value) == null ? void 0 : _c.paymentMethod) == null ? void 0 : _d.afterOrderEnabled);
    }
  );
  async function handlePayment$1(finishUrl, errorUrl, paymentDetails) {
    var _a;
    if (!order.value) {
      return;
    }
    const resp = await handlePayment(
      {
        orderId: (_a = order.value) == null ? void 0 : _a.id,
        finishUrl,
        errorUrl,
        paymentDetails
      },
      apiInstance
    );
    paymentUrl.value = resp == null ? void 0 : resp.redirectUrl;
    return resp;
  }
  async function changePaymentMethod(paymentMethodId) {
    var _a;
    if (!order.value) {
      return;
    }
    changeOrderPaymentMethod((_a = order.value) == null ? void 0 : _a.id, paymentMethodId, apiInstance);
  }
  return {
    isAsynchronous,
    activeTransaction,
    state,
    paymentUrl,
    paymentMethod,
    handlePayment: handlePayment$1,
    changePaymentMethod
  };
}
var _wishlistItems$1 = ref([]);
function useLocalWishlist() {
  const updateStorage = () => {
    localStorage.setItem(
      "sw-wishlist-items",
      JSON.stringify(_wishlistItems$1.value)
    );
  };
  const getFromStorage = () => {
    if (typeof window != "undefined" && localStorage) {
      return JSON.parse(localStorage.getItem("sw-wishlist-items") ?? "[]");
    }
  };
  async function removeFromWishlist(id) {
    var _a;
    _wishlistItems$1.value = (_a = _wishlistItems$1.value) == null ? void 0 : _a.filter(
      (itemId) => itemId != id
    );
    updateStorage();
  }
  async function addToWishlist(id) {
    if (!_wishlistItems$1.value.includes(id)) {
      _wishlistItems$1.value.push(id);
      updateStorage();
    }
  }
  async function clearWishlist() {
    _wishlistItems$1.value = [];
    updateStorage();
  }
  function getWishlistProducts2() {
    const currentWishlist = getFromStorage();
    if (Array.isArray(currentWishlist) && currentWishlist.length) {
      _wishlistItems$1.value = currentWishlist;
    }
  }
  const items = computed(() => _wishlistItems$1.value);
  const count = computed(() => items.value.length);
  return {
    getWishlistProducts: getWishlistProducts2,
    addToWishlist,
    removeFromWishlist,
    clearWishlist,
    items,
    count
  };
}
var _wishlistItems = ref([]);
function useSyncWishlist() {
  const { apiInstance } = useShopwareContext();
  async function addToWishlistSync(id) {
    await addWishlistProduct(id, apiInstance);
    getWishlistProducts$1();
  }
  async function removeFromWishlistSync(id) {
    await removeWishlistProduct(id, apiInstance);
    getWishlistProducts$1();
  }
  async function getWishlistProducts$1() {
    const response = await getWishlistProducts(void 0, apiInstance);
    _wishlistItems.value = [
      ...response.products.elements.map((element) => element.id)
    ];
  }
  async function mergeWishlistProducts$1(itemsToMerge) {
    await mergeWishlistProducts(itemsToMerge, apiInstance);
  }
  const items = computed(() => _wishlistItems.value);
  const count = computed(() => items.value.length);
  return {
    getWishlistProducts: getWishlistProducts$1,
    addToWishlistSync,
    removeFromWishlistSync,
    mergeWishlistProducts: mergeWishlistProducts$1,
    items,
    count
  };
}
function useProductSearchSuggest() {
  const searchTerm = ref("");
  const listingComposable = useListing({
    listingType: "productSearchListing"
  });
  const search = async (additionalCriteria = {}) => {
    const searchCriteria = {
      query: searchTerm.value,
      ...additionalCriteria
    };
    return listingComposable.search(searchCriteria, {
      preventRouteChange: true
    });
  };
  return {
    searchTerm,
    loading: listingComposable.loading,
    search,
    loadMore: listingComposable.loadMore,
    getProducts: listingComposable.getElements,
    getTotal: listingComposable.getTotal
  };
}
function useCustomerPassword() {
  const { apiInstance } = useShopwareContext();
  const errors = reactive({
    resetPassword: [],
    updatePassword: []
  });
  async function updatePassword$1(updatePasswordData) {
    try {
      errors.updatePassword = [];
      await updatePassword(updatePasswordData, apiInstance);
    } catch (e) {
      errors.updatePassword = e.messages;
      return false;
    }
    return true;
  }
  async function resetPassword$1(resetPasswordData) {
    try {
      await resetPassword(resetPasswordData, apiInstance);
    } catch (e) {
      errors.resetPassword = e.messages;
      return false;
    }
    return true;
  }
  return {
    updatePassword: updatePassword$1,
    resetPassword: resetPassword$1,
    errors
  };
}
function useCustomerOrders() {
  const { apiInstance } = useShopwareContext();
  const orders = ref([]);
  const loadOrders = async (parameters = {}) => {
    const fetchedOrders = await getCustomerOrders(parameters, apiInstance);
    orders.value = fetchedOrders == null ? void 0 : fetchedOrders.elements;
  };
  const changeCurrentPage = async (pageNumber) => await loadOrders({ page: +pageNumber });
  return {
    orders,
    changeCurrentPage,
    loadOrders
  };
}
function createShopwareContext(app, options) {
  const scope = effectScope(true);
  const state = scope.run(() => {
    return reactive({
      interceptors: {}
      // sharedStore: options.initialStore || reactive({}),
      // shopwareDefaults: options.shopwareDefaults || {},
    });
  });
  const shopwarePlugin = markRaw({
    install(app2, options2) {
      shopwarePlugin._a = app2;
      app2.config.globalProperties.$shopware = shopwarePlugin;
      app2.provide("shopware", shopwarePlugin);
      if ((options2 == null ? void 0 : options2.enableDevtools) && typeof window !== "undefined")
        ;
    },
    _a: app,
    _e: scope,
    apiInstance: options.apiInstance,
    state
  });
  if ((options == null ? void 0 : options.enableDevtools) && typeof window !== "undefined")
    ;
  return shopwarePlugin;
}
function useAddress() {
  const { apiInstance } = useShopwareContext();
  useUser();
  const _storeCustomerAddresses = inject(
    "swCustomerAddresses",
    ref([])
  );
  provide("swCustomerAddresses", _storeCustomerAddresses);
  async function loadCustomerAddresses(parameters = {}) {
    const { elements } = await getCustomerAddresses(parameters, apiInstance);
    _storeCustomerAddresses.value = elements;
  }
  async function createCustomerAddress$1(customerAddress) {
    const result = await createCustomerAddress(customerAddress, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function updateCustomerAddress$1(customerAddress) {
    const result = await updateCustomerAddress(customerAddress, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function deleteCustomerAddress$1(addressId) {
    const result = deleteCustomerAddress(addressId, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function setDefaultCustomerBillingAddress$1(addressId) {
    return await setDefaultCustomerBillingAddress(addressId, apiInstance);
  }
  async function setDefaultCustomerShippingAddress$1(addressId) {
    return await setDefaultCustomerShippingAddress(addressId, apiInstance);
  }
  return {
    customerAddresses: computed(() => _storeCustomerAddresses.value || []),
    loadCustomerAddresses,
    createCustomerAddress: createCustomerAddress$1,
    updateCustomerAddress: updateCustomerAddress$1,
    deleteCustomerAddress: deleteCustomerAddress$1,
    setDefaultCustomerBillingAddress: setDefaultCustomerBillingAddress$1,
    setDefaultCustomerShippingAddress: setDefaultCustomerShippingAddress$1
  };
}
function useProductPrice(product) {
  const _cheapest = computed(
    () => {
      var _a;
      return (_a = product.value) == null ? void 0 : _a.calculatedCheapestPrice;
    }
  );
  const _real = computed(
    () => {
      var _a, _b, _c, _d;
      return ((_b = (_a = product.value) == null ? void 0 : _a.calculatedPrices) == null ? void 0 : _b.length) > 0 ? (_c = product.value) == null ? void 0 : _c.calculatedPrices[0] : (_d = product.value) == null ? void 0 : _d.calculatedPrice;
    }
  );
  const referencePrice = computed(
    () => {
      var _a;
      return (_a = _real == null ? void 0 : _real.value) == null ? void 0 : _a.referencePrice;
    }
  );
  const _displayParent = computed(
    () => {
      var _a, _b, _c;
      return ((_b = (_a = product.value) == null ? void 0 : _a.variantListingConfig) == null ? void 0 : _b.displayParent) && ((_c = product.value) == null ? void 0 : _c.parentId) === null;
    }
  );
  const displayFrom = computed(
    () => {
      var _a, _b;
      return ((_b = (_a = product.value) == null ? void 0 : _a.calculatedPrices) == null ? void 0 : _b.length) > 1 || !!(_displayParent.value && displayFromVariants.value);
    }
  );
  const displayFromVariants = computed(
    () => {
      var _a, _b, _c, _d, _e, _f, _g;
      return !!product.value.parentId && ((_b = (_a = product.value) == null ? void 0 : _a.cheapestPrice) == null ? void 0 : _b.hasRange) && !!((_d = (_c = product.value) == null ? void 0 : _c.cheapestPrice) == null ? void 0 : _d.parentId) && ((_e = _real == null ? void 0 : _real.value) == null ? void 0 : _e.unitPrice) !== ((_f = _cheapest == null ? void 0 : _cheapest.value) == null ? void 0 : _f.unitPrice) && ((_g = _cheapest == null ? void 0 : _cheapest.value) == null ? void 0 : _g.unitPrice);
    }
  );
  const _price = computed(() => {
    var _a;
    if (displayFrom.value && getProductTierPrices(product.value).length > 1) {
      const lowest = (_a = product.value) == null ? void 0 : _a.calculatedPrices.reduce(
        (previous, current) => {
          return current.unitPrice < previous.unitPrice ? current : previous;
        }
      );
      return lowest || _cheapest.value;
    }
    return _real.value;
  });
  const unitPrice = computed(
    () => {
      var _a;
      return (_a = _price.value) == null ? void 0 : _a.unitPrice;
    }
  );
  const totalPrice = computed(
    () => {
      var _a;
      return (_a = _price.value) == null ? void 0 : _a.totalPrice;
    }
  );
  const price = computed(
    () => _price.value
  );
  const isListPrice = computed(
    () => {
      var _a, _b;
      return !!((_b = (_a = _price.value) == null ? void 0 : _a.listPrice) == null ? void 0 : _b.percentage);
    }
  );
  const tierPrices = computed(() => getProductTierPrices(product.value));
  return {
    price,
    totalPrice,
    unitPrice,
    displayFromVariants,
    displayFrom,
    tierPrices,
    referencePrice,
    isListPrice
  };
}
function useInternationalization() {
  const { apiInstance } = useShopwareContext();
  function getStorefrontUrl() {
    return apiInstance.config.endpoint ?? window.location.origin ?? "";
  }
  return {
    getStorefrontUrl
  };
}
function useCmsMeta(entity) {
  const meta = computed(() => {
    const entries = [];
    const keywords = getTranslatedProperty(entity, "keywords");
    const description = getTranslatedProperty(entity, "metaDescription");
    const title = getTranslatedProperty(entity, "metaTitle");
    if (keywords) {
      entries.push({ name: "keywords", content: keywords });
    }
    if (description) {
      entries.push({ name: "description", content: description });
    }
    if (title) {
      entries.push({ name: "title", content: title });
    }
    return entries;
  });
  return {
    title: computed(() => getTranslatedProperty(entity, "name")),
    meta
  };
}
function useNewsletter() {
  const { apiInstance } = useShopwareContext();
  const { getStorefrontUrl } = useInternationalization();
  const newsletterStatus = ref(
    "undefined"
    /* UNDEFINED */
  );
  async function newsletterSubscribe$1(params) {
    return await newsletterSubscribe(
      {
        ...params,
        storefrontUrl: getStorefrontUrl()
      },
      apiInstance
    );
  }
  async function newsletterUnsubscribe$1(email) {
    return await newsletterUnsubscribe(
      {
        email
      },
      apiInstance
    );
  }
  async function getNewsletterStatus() {
    try {
      const response = await isNewsletterSubscriber(apiInstance);
      newsletterStatus.value = response.status;
    } catch (error) {
      console.error(error);
    }
  }
  const isNewsletterSubscriber$1 = computed(
    () => ![
      "optOut",
      "undefined"
      /* UNDEFINED */
    ].includes(
      newsletterStatus.value
    )
  );
  const confirmationNeeded = computed(
    () => newsletterStatus.value === "notSet"
    /* NOT_SET */
  );
  return {
    newsletterSubscribe: newsletterSubscribe$1,
    newsletterUnsubscribe: newsletterUnsubscribe$1,
    isNewsletterSubscriber: isNewsletterSubscriber$1,
    getNewsletterStatus,
    newsletterStatus,
    confirmationNeeded
  };
}
function useNavigationContext(context) {
  const _context = _useContext("navigation", { context });
  const routeName = computed(() => {
    var _a;
    return (_a = _context.value) == null ? void 0 : _a.routeName;
  });
  const foreignKey = computed(() => {
    var _a;
    return ((_a = _context.value) == null ? void 0 : _a.foreignKey) || "";
  });
  return {
    navigationContext: computed(() => _context.value),
    routeName,
    foreignKey
  };
}
function useNavigationSearch() {
  const { apiInstance } = useShopwareContext();
  const { sessionContext } = useSessionContext();
  async function resolvePath(path) {
    var _a, _b, _c;
    if (path === "/") {
      const categoryId = (_b = (_a = sessionContext.value) == null ? void 0 : _a.salesChannel) == null ? void 0 : _b.navigationCategoryId;
      return {
        routeName: "frontend.navigation.page",
        foreignKey: categoryId
      };
    }
    const isTechnicalUrl = path.startsWith("/navigation/") || path.startsWith("/detail/") || path.startsWith("/landingPage/");
    const normalizedPath = isTechnicalUrl ? path : path.substring(1);
    const seoResult = await getSeoUrl(
      {
        filter: [
          {
            type: "equals",
            field: isTechnicalUrl ? "pathInfo" : "seoPathInfo",
            value: normalizedPath
          }
        ]
      },
      apiInstance
    );
    return (_c = seoResult.elements) == null ? void 0 : _c[0];
  }
  return {
    resolvePath
  };
}
function useWishlist() {
  const { isLoggedIn, isGuestSession } = useUser();
  const canSyncWishlist = computed(
    () => isLoggedIn.value && !isGuestSession.value
  );
  const {
    getWishlistProducts: getWishlistProductsLocal,
    items: itemsLocal,
    clearWishlist: clearWishlistLocal
  } = useLocalWishlist();
  const {
    getWishlistProducts: getWishlistProductsSync,
    items: itemsSync,
    mergeWishlistProducts: mergeWishlistProductsSync
  } = useSyncWishlist();
  const getWishlistProducts2 = async () => {
    if (canSyncWishlist.value) {
      await getWishlistProductsSync();
    } else {
      await getWishlistProductsLocal();
    }
  };
  const clearWishlist = () => {
    clearWishlistLocal();
  };
  const mergeWishlistProducts2 = async () => {
    var _a;
    if ((_a = itemsLocal.value) == null ? void 0 : _a.length) {
      await mergeWishlistProductsSync(itemsLocal.value);
      clearWishlist();
    }
    getWishlistProductsSync();
  };
  const items = computed(
    () => canSyncWishlist.value ? itemsSync.value : itemsLocal.value
  );
  const count = computed(() => items.value.length);
  return {
    mergeWishlistProducts: mergeWishlistProducts2,
    getWishlistProducts: getWishlistProducts2,
    clearWishlist,
    items,
    count
  };
}
function useProductWishlist(product) {
  const { isLoggedIn } = useUser();
  const {
    addToWishlist: addItem,
    removeFromWishlist: removeItem,
    items
  } = useLocalWishlist();
  const {
    addToWishlistSync: addItemSync,
    removeFromWishlistSync: removeItemSync,
    items: itemsSync
  } = useSyncWishlist();
  async function removeFromWishlist() {
    if (isLoggedIn.value) {
      await removeItemSync(product.value.id);
    } else {
      await removeItem(product.value.id);
    }
  }
  async function addToWishlist() {
    if (isLoggedIn.value) {
      await addItemSync(product.value.id);
    } else {
      await addItem(product.value.id);
    }
  }
  const isInWishlist = computed(
    () => {
      var _a, _b;
      return isLoggedIn.value ? (_a = itemsSync.value) == null ? void 0 : _a.includes(product.value.id) : (_b = items.value) == null ? void 0 : _b.includes(product.value.id);
    }
  );
  return {
    addToWishlist,
    removeFromWishlist,
    isInWishlist
  };
}
function useBreadcrumbs(newBreadcrumbs) {
  const _breadcrumbs = _useContext("swBreadcrumb", {
    replace: newBreadcrumbs
  });
  const clearBreadcrumbs = () => {
    _breadcrumbs.value = [];
  };
  return {
    clearBreadcrumbs,
    breadcrumbs: computed(() => _breadcrumbs.value)
  };
}
function resolveCmsComponent(content) {
  const componentName = content.type;
  const type = content.apiAlias === "cms_block" ? "Block" : content.apiAlias === "cms_section" ? "Section" : "Element";
  const componentNameToResolve = pascalCase(`Cms-${type}-${componentName}`);
  try {
    const resolvedComponent = resolveComponent(componentNameToResolve);
    return {
      componentName,
      isResolved: resolvedComponent !== componentName,
      resolvedComponent: typeof resolvedComponent !== "string" ? resolvedComponent : void 0
    };
  } catch (e) {
    return {
      componentName,
      resolvedComponent: void 0,
      resolved: false,
      error: e.message
    };
  }
}
function getDefaultApiParams() {
  return {};
}
export {
  CATEGORY_ROUTE_NAME,
  LANDING_PAGE_ROUTE_NAME,
  PRODUCT_ROUTE_NAME,
  createListingComposable,
  createShopwareContext,
  getDefaultApiParams,
  resolveCmsComponent,
  useAddToCart,
  useAddress,
  useBreadcrumbs,
  useCart,
  useCartFunction,
  useCartItem,
  useCategory,
  useCategorySearch,
  useCheckout,
  useCmsBlock,
  useCmsElementConfig,
  useCmsElementImage,
  useCmsMeta,
  useCmsSection,
  useCountries,
  useCustomerOrders,
  useCustomerPassword,
  useInternationalization,
  useLandingSearch,
  useListing,
  useLocalWishlist,
  useNavigation,
  useNavigationContext,
  useNavigationSearch,
  useNewsletter,
  useNotifications,
  useOrderDetails,
  useOrderPayment,
  usePrice,
  useProduct,
  useProductAssociations,
  useProductConfigurator,
  useProductPrice,
  useProductReviews,
  useProductSearch,
  useProductSearchSuggest,
  useProductWishlist,
  useSalutations,
  useSessionContext,
  useShopwareContext,
  useSyncWishlist,
  useUser,
  useWishlist
};
//# sourceMappingURL=@shopware-pwa_composables-next.js.map
