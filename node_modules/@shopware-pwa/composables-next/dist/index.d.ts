import * as vue from 'vue';
import { CSSProperties, ComputedRef, AnchorHTMLAttributes, ImgHTMLAttributes, Ref, UnwrapRef, App } from 'vue';
import { CmsBlock, CmsSlot, Media, ProductMedia, Product, ProductListingResult, EntityResult, ProductReview, PropertyGroup, CrossSelling, Salutation, SectionType, CmsSection, Category, ProductResponse as ProductResponse$1, LandingPage, CmsPage, ShopwareSearchParams, StoreNavigationElement, StoreNavigationType, Cart, LineItem, EntityError, PropertyGroupOptionCart, LineItemType, CustomerRegistrationParams, Customer, Country, PaymentMethodTranslation, BillingAddress, ShippingAddress, Language, SessionContext, ShippingMethod, PaymentMethod, Currency, ListingResult, Sort, ListingFilter, CreateOrderParams, Order, OrderDocument, ShopwareAssociation, OrderTransaction, StateMachineState, ShopwareError, CustomerAddress, CalculatedPrice, ReferencePrice, CmsPageEntity, NewsletterInput, SeoUrl, RouteName } from '@shopware-pwa/types';
import { ShopwareApiInstance, CustomerUpdateProfileParam, CustomerUpdateEmailParam, CustomerUpdatePasswordParam, CustomerResetPasswordParam } from '@shopware-pwa/api-client';
import { TierPrice } from '@shopware-pwa/helpers-next';

type BlockType<SLOT_NAMES> = CmsBlock & {
    slots: Array<CmsSlot & {
        slot: SLOT_NAMES;
    }>;
};
type THREE_COLUMNS = "left" | "center" | "right";
type TWO_COLUMNS = "left" | "right";
type CmsBlockText = BlockType<"content">;
type CmsBlockTextHero = BlockType<"content">;
type CmsBlockTextTeaser = BlockType<"content">;
type CmsBlockTextTeaserSection = BlockType<TWO_COLUMNS>;
type CmsBlockTextTwoColumn = BlockType<TWO_COLUMNS>;
type CmsBlockTextThreeColumn = BlockType<THREE_COLUMNS>;
type CmsBlockImage = BlockType<"image">;
type CmsBlockImageCover = BlockType<"image">;
type CmsBlockImageTwoColumn = BlockType<TWO_COLUMNS>;
type CmsBlockImageThreeColumn = BlockType<THREE_COLUMNS>;
type CmsBlockImageThreeCover = BlockType<THREE_COLUMNS>;
type CmsBlockImageFourColumn = BlockType<"left" | "center-left" | "center-right" | "right">;
type CmsBlockImageBubbleRow = BlockType<THREE_COLUMNS>;
type CmsBlockImageHighlightRow = BlockType<THREE_COLUMNS>;
type CmsBlockImageSimpleGrid = BlockType<"left-top" | "left-bottom" | "right">;
type CmsBlockImageSlider = BlockType<"imageSlider">;
type CmsBlockImageGallery = BlockType<"imageGallery">;
type CmsBlockYoutubeVideo = BlockType<"video">;
type CmsBlockVimeoVideo = BlockType<"video">;
type CmsBlockImageText = BlockType<TWO_COLUMNS>;
type CmsBlockImageTextCover = BlockType<TWO_COLUMNS>;
type CmsBlockCenterText = BlockType<THREE_COLUMNS>;
type CmsBlockImageTextRow = BlockType<"left-image" | "left-text" | "center-image" | "center-text" | "right-image" | "right-text">;
type CmsBlockImageTextGallery = BlockType<"left-image" | "left-text" | "center-image" | "center-text" | "right-image" | "right-text">;
type CmsBlockImageTextBubble = BlockType<"left-image" | "left-text" | "center-image" | "center-text" | "right-image" | "right-text">;
type CmsBlockTextOnImage = BlockType<"content">;
type CmsBlockSidebarFilter = BlockType<"content">;
type CmsBlockCategoryNavigation = BlockType<"content">;
type CmsBlockProductHeading = BlockType<TWO_COLUMNS>;
type CmsBlockProductThreeColumn = BlockType<THREE_COLUMNS>;
type CmsBlockProductListing = BlockType<"content">;
type CmsBlockProductSlider = BlockType<"productSlider">;
type CmsBlockGalleryBuybox = BlockType<TWO_COLUMNS>;
type CmsBlockProductDescriptionReviews = BlockType<"content">;
type CmsBlockCrossSelling = BlockType<"content">;
type CmsBlockForm = BlockType<"content">;

type SourceType = "static" | "mapped";
type Position = "left" | "center" | "right";
type DisplayMode = Exclude<CSSProperties["objectFit"], undefined> | "standard";
type BoxLayout = "standard" | "image" | "minimal";
type VerticalAlign = "flex-start" | "center" | "flex-end" | "";
type ElementConfig<VALUE_TYPE> = {
    source: SourceType;
    value: VALUE_TYPE;
};
type TextElementConfig = {
    content: ElementConfig<string>;
    verticalAlign: ElementConfig<VerticalAlign>;
};
type ElementFieldConfig = {
    name: string;
    source: SourceType;
    value: string | null;
    apiAlias: string;
};
type CmsElementText = CmsSlot & {
    type: "text" | typeof String;
    slot: typeof String;
    config: TextElementConfig;
    fieldConfig: ElementFieldConfig[];
    data: {
        content: string;
        apiAlias: "cms_text";
    };
    translated: {
        config: TextElementConfig;
    };
};
type ImageElementConfig = {
    url: ElementConfig<string>;
    media: ElementConfig<string>;
    newTab: ElementConfig<boolean>;
    product: ElementConfig<string>;
    boxLayout: ElementConfig<BoxLayout>;
    displayMode: ElementConfig<DisplayMode>;
    minHeight: ElementConfig<string | number>;
    verticalAlign: ElementConfig<VerticalAlign>;
};
type CmsElementImage = CmsSlot & {
    type: "image";
    config: ImageElementConfig;
    data: {
        mediaId: string;
        url: string;
        newTab: boolean;
        apiAlias: "cms_image";
        media: Media;
    };
};
type SliderElementConfig = {
    minHeight: ElementConfig<string | number>;
    verticalAlign?: ElementConfig<VerticalAlign>;
    displayMode?: ElementConfig<"standard" | "cover" | "contain">;
    navigationDots?: ElementConfig<"outside" | "inside" | "">;
    navigationArrows?: ElementConfig<"outside" | "inside" | "">;
};
type ImageSliderElementConfig = ImageElementConfig & SliderElementConfig & {
    sliderItems: ElementConfig<Array<{
        url: null | string;
        newTab: boolean;
        mediaId: string;
        mediaUrl: string;
    }>>;
};
type CmsElementImageSlider = CmsSlot & {
    type: "image-slider";
    config: ImageSliderElementConfig;
    data: {
        apiAlias: "cms_image_slider";
        navigation: unknown;
        sliderItems: {
            url: string;
            newTab: boolean;
            media: Media;
            mediaId: string;
            apiAlias: "cms_image_slider_item";
        }[];
    };
};
type ImageGalleryElementConfig = ImageSliderElementConfig & {
    galleryPosition: ElementConfig<Position>;
    magnifierOverGallery: ElementConfig<boolean>;
    keepAspectRatioOnZoom: ElementConfig<boolean>;
    fullScreen: ElementConfig<boolean>;
    zoom: ElementConfig<boolean>;
};
type CmsElementImageGallery = CmsSlot & {
    type: "image-gallery";
    config: ImageGalleryElementConfig;
    data: {
        apiAlias: "cms_image_slider";
        navigation: unknown;
        sliderItems: Array<{
            url: null | string;
            newTab: boolean;
            media: Media;
            apiAlias: "cms_image_slider_item";
        } | ProductMedia>;
    };
};
type YouTubeVideoElementConfig = {
    end: ElementConfig<string>;
    url: ElementConfig<string>;
    loop: ElementConfig<boolean>;
    start: ElementConfig<string>;
    videoID: ElementConfig<string>;
    autoPlay: ElementConfig<boolean>;
    displayMode: ElementConfig<DisplayMode>;
    previewMedia: ElementConfig<string>;
    showControls: ElementConfig<boolean>;
    needsConfirmation: ElementConfig<boolean>;
    advancePrivacyMode: ElementConfig<boolean>;
};
type CmsElementYoutubeVideo = CmsSlot & {
    type: "youtube-video";
    config: YouTubeVideoElementConfig;
    data: {
        mediaId: string | null;
        url: null | string;
        newTab: null | boolean;
        media: null | Media;
        apiAlias: "cms_image";
    };
};
type VimeoVideoElementConfig = {
    loop: ElementConfig<boolean>;
    color: ElementConfig<string>;
    title: ElementConfig<boolean>;
    mute: ElementConfig<boolean>;
    byLine: ElementConfig<boolean>;
    videoID: ElementConfig<string>;
    autoplay: ElementConfig<boolean>;
    controls: ElementConfig<boolean>;
    portrait: ElementConfig<boolean>;
    doNotTrack: ElementConfig<boolean>;
    previewMedia: ElementConfig<string>;
    needsConfirmation: ElementConfig<boolean>;
};
type CmsElementVimeoVideo = CmsSlot & {
    type: "vimeo-video";
    config: VimeoVideoElementConfig;
    data: {
        mediaId: string | null;
        url: null | string;
        newTab: null | boolean;
        media: null | Media;
        apiAlias: "cms_image";
    };
};
type ProductBoxElementConfig = {
    boxLayout: ElementConfig<BoxLayout>;
    product: ElementConfig<string>;
};
type CmsElementProductBox = CmsSlot & {
    type: "product-box";
    config: ProductBoxElementConfig;
    data: {
        productId: string;
        product: Product;
        apiAlias: "cms_product_box";
    };
};
type ProductSliderElementConfig = {
    title: ElementConfig<string>;
    border: ElementConfig<boolean>;
    rotate: ElementConfig<boolean>;
    products: ElementConfig<string[]>;
    boxLayout: ElementConfig<BoxLayout>;
    elMinWidth: ElementConfig<string>;
    navigation: ElementConfig<boolean>;
    displayMode: ElementConfig<DisplayMode>;
    verticalAlign: ElementConfig<VerticalAlign>;
    productStream: ElementConfig<string>;
    productStreamSorting: ElementConfig<string>;
};
type CmsElementProductSlider = CmsSlot & {
    type: "product-slider";
    config: ProductSliderElementConfig;
    data: {
        apiAlias: "cms_product_slider";
        products: Product[];
    };
};
type CmsSidebarFilterElementConfig = unknown;
type CmsElementSidebarFilter = CmsSlot & {
    type: "sidebar-filter";
    config: CmsSidebarFilterElementConfig;
};
type CmsProductListingElementConfig = {
    filters: ElementConfig<string>;
    boxLayout: ElementConfig<BoxLayout>;
    showSorting: ElementConfig<boolean>;
    defaultSorting: ElementConfig<string>;
    useCustomSorting: ElementConfig<boolean>;
    availableSortings: ElementConfig<string[]>;
    propertyWhitelist: ElementConfig<string[]>;
};
type CmsElementProductListing = CmsSlot & {
    type: "product-listing";
    config: CmsProductListingElementConfig;
    data: {
        apiAlias: "cms_product_listing";
        listing: ProductListingResult;
    };
};
type CategoryNavigationElementConfig = unknown;
type CmsElementCategoryNavigation = CmsSlot & {
    type: "category-navigation";
    config: CategoryNavigationElementConfig;
};
type ProductDescriptionReviewsElementConfig = {
    product: ElementConfig<string>;
    alignment: ElementConfig<VerticalAlign>;
};
type CmsElementProductDescriptionReviews = CmsSlot & {
    type: "product-description-reviews";
    config: ProductDescriptionReviewsElementConfig;
    data: {
        productId: null | string;
        ratingSuccess: boolean;
        product?: Product;
        reviews: EntityResult<"product_review", ProductReview>;
        apiAlias: "cms_product_description_reviews";
    };
};
type BuyBoxElementConfig = ProductDescriptionReviewsElementConfig;
type CmsElementBuyBox = CmsSlot & {
    type: "buy-box";
    config: BuyBoxElementConfig;
    data: {
        configuratorSettings: PropertyGroup[] | null;
        productId: null | string;
        ratingSuccess: boolean;
        product?: Product;
        reviews: EntityResult<"product_review", ProductReview>;
        apiAlias: "cms_product_description_reviews";
    };
};
type CrossSellingElementConfig = {
    product: ElementConfig<string>;
    alignment: ElementConfig<VerticalAlign>;
    boxLayout: ElementConfig<BoxLayout>;
    elMinWidth: ElementConfig<string>;
    displayMode: ElementConfig<DisplayMode>;
};
type CmsElementCrossSelling = CmsSlot & {
    type: "cross-selling";
    config: CrossSellingElementConfig;
    data: {
        apiAlias: "cms_cross_selling";
        crossSellings: CrossSelling[];
    };
};
type FormElementConfig = {
    type: ElementConfig<"contact" | "newsletter">;
    title: ElementConfig<string>;
    mailReceiver: ElementConfig<string[]>;
    confirmationText: ElementConfig<string>;
    defaultMailReceiver: ElementConfig<boolean>;
};
type CmsElementForm = CmsSlot & {
    type: "form";
    config: FormElementConfig;
    data: Salutation[];
};
type CmsElementProductName = CmsSlot & {
    type: "product-name";
    config: TextElementConfig;
    fieldConfig: ElementFieldConfig[];
    data: {
        content: string;
        apiAlias: "cms_text";
    };
    translated: {
        config: TextElementConfig;
    };
};
type CmsElementManufacturerLogo = CmsSlot & {
    type: "manufacturer-logo";
    config: ImageElementConfig;
    data: {
        mediaId: string;
        url: string;
        newTab: boolean;
        apiAlias: "cms_manufacturer_logo";
        media: Media;
    };
};

type CmsSectionBlock<TYPE extends SectionType, SECTION_POSITIONS> = CmsSection & {
    type: TYPE;
    blocks: Array<CmsBlock & {
        sectionPosition: SECTION_POSITIONS;
    }>;
};
type CmsSectionDefault = CmsSectionBlock<"default", "main">;
type CmsSectionSidebar = CmsSectionBlock<"sidebar", "sidebar" | "main">;

/**
 * API responses' types
 * A combination of legacy response types and new response types
 * @TODO: to be unified in the final types package
 */
type CategoryResponse = Category;
type ProductResponse = ProductResponse$1;
type LandingPageResponse = LandingPage;
/**
 * Types for internal usage.
 *
 * @TODO: rethink the format of the types
 */
declare const PRODUCT_ROUTE_NAME = "frontend.detail.page";
declare const CATEGORY_ROUTE_NAME = "frontend.navigation.page";
declare const LANDING_PAGE_ROUTE_NAME = "frontend.landing.page";
type ResourceType = typeof PRODUCT_ROUTE_NAME | typeof CATEGORY_ROUTE_NAME | typeof LANDING_PAGE_ROUTE_NAME;
type CategoryCmsResult = {
    category: CategoryResponse;
};
type ProductCmsResult = ProductResponse;
type LandingPageCmsResult = {
    landingPage: LandingPage;
};
type SearchCmsResult = (CategoryCmsResult | ProductCmsResult | LandingPageCmsResult) & {
    cmsPage: null | CmsPage;
    resourceType: ResourceType;
};

type UseCmsElementImage = {
    containerStyle: ComputedRef<CSSProperties>;
    anchorAttrs: ComputedRef<AnchorHTMLAttributes>;
    imageAttrs: ComputedRef<ImgHTMLAttributes>;
    imageContainerAttrs: ComputedRef<CSSProperties>;
    imageLink: ComputedRef<{
        newTab: boolean;
        url: string;
    }>;
    displayMode: ComputedRef<DisplayMode>;
};
/**
 * Composable to get cms element image
 *
 * @category CMS (Shopping Experiences)
 */
declare function useCmsElementImage(element: CmsElementImage | CmsElementManufacturerLogo): UseCmsElementImage;

/**
 * Composable to get cms element config
 *
 * @category CMS (Shopping Experiences)
 */
declare function useCmsElementConfig<T extends CmsSlot & {
    config: T["config"] extends {
        [key in infer X extends keyof T["config"]]: ElementConfig<unknown>;
    } ? {
        [key in X]: ElementConfig<T["config"][key]["value"]>;
    } : never;
}>(element: T): {
    getConfigValue: <ELEMENT_CONFIG extends keyof T["config"]>(key: ELEMENT_CONFIG) => (T["config"] extends { [key in infer X extends keyof T["config"]]: ElementConfig<unknown>; } ? { [key_1 in X]: ElementConfig<T["config"][key_1]["value"]>; } : never)[ELEMENT_CONFIG]["value"];
};

type ShopwareContext = {
    /**
     * Shopware API instance
     */
    apiInstance: ShopwareApiInstance;
};
/**
 * @public
 * @category Context & Language
 */
declare function useShopwareContext(): ShopwareContext;

type UseCategoryReturn = {
    /**
     * Current category entity
     */
    category: ComputedRef<Category>;
};
/**
 * Composable to get the category from current CMS context
 *
 * @public
 */
declare function useCategory(category?: Ref<Category>): UseCategoryReturn;

type UseCategorySearchReturn = {
    /**
     * Search for category by ID
     * Accepts optional query params and associations
     */
    search(categoryId: string, options?: {
        withCmsAssociations?: boolean;
        query?: Partial<ShopwareSearchParams>;
    }): Promise<Category>;
};
/**
 * Composable for category search.
 * @public
 * @category Navigation & Routing
 */
declare function useCategorySearch(): UseCategorySearchReturn;

type UseProductConfiguratorReturn = {
    /**
     * Handler for action when the selected option is changed
     */
    handleChange(attribute: string, option: string, onChangeHandled: () => void): Promise<void>;
    findVariantForSelectedOptions(options?: {
        [key: string]: string;
    }): Promise<Product | undefined>;
    /**
     * Indicates if the options are being (re)loaded
     */
    isLoadingOptions: Ref<boolean>;
    /**
     * Object of currently selected options
     */
    getSelectedOptions: ComputedRef<{
        [key: string]: string;
    }>;
    /**
     * All assigned properties which the variant can be made of
     */
    getOptionGroups: ComputedRef<PropertyGroup[]>;
};
/**
 * Composable to change product variant.
 * @public
 * @category Product
 */
declare function useProductConfigurator(): UseProductConfiguratorReturn;

type UseProductReviewsReturn = {
    /**
     * All reviews added to the product
     */
    productReviews: ComputedRef<ProductReview[]>;
    /**
     * Adds a review to the product
     * @param data `title` - review title, `content` - review content, `points` - review points (range of 1-5)
     * @returns
     */
    addReview(data: {
        title: string;
        content: string;
        points: number;
    }): Promise<void>;
    /**
     * Fetches the reviews list and assigns the result to the `productReviews` property
     * @param parameters {@link ShopwareSearchParams}
     * @returns
     */
    loadProductReviews(parameters?: ShopwareSearchParams): Promise<void>;
};
/**
 * Composable for listing customer orders.
 * @public
 * @category Product
 */
declare function useProductReviews(product: Ref<Product>): UseProductReviewsReturn;

type UseProductAssociationsReturn = {
    /**
     * Start loading resources. Search Parameters and HTTP method can be passed.
     *
     */
    loadAssociations(params: {
        method?: "post" | "get";
        searchParams: ShopwareSearchParams;
    }): Promise<void>;
    /**
     * If it's loading - indicator
     */
    isLoading: ComputedRef<boolean>;
    /**
     * Product associations, like CrossSelling[]
     */
    productAssociations: ComputedRef<CrossSelling[]>;
};
/**
 * Get product association entity.
 * @public
 * @category Product
 */
declare function useProductAssociations(product: ComputedRef<Product>, options: {
    associationContext: "cross-selling" | "reviews";
}): UseProductAssociationsReturn;

type ArrayElement$1<ArrayType extends readonly unknown[]> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;
type UseCmsBlockReturn = {
    /**
     * Cms block content
     */
    block: CmsBlock;
    /**
     * Get slot content by slot name (identifier)
     * @example getSlotContent("main")
     */
    getSlotContent(slotName: string): ArrayElement$1<CmsBlock["slots"]>;
};
/**
 * Composable to get cms block content
 * @public
 * @category CMS (Shopping Experiences)
 */
declare function useCmsBlock<BLOCK_TYPE extends CmsBlock>(content: BLOCK_TYPE): UseCmsBlockReturn;

type ArrayElement<ArrayType extends readonly unknown[]> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;
type UseCmsSectionType = {
    /**
     * CMS section
     */
    section: CmsSection;
    /**
     * Position of the section
     */
    getPositionContent(position: ArrayElement<CmsSection["blocks"]>["sectionPosition"]): Array<CmsBlock>;
};
/**
 * Composable to get cms section content
 * @public
 * @category CMS (Shopping Experiences)
 */
declare function useCmsSection<SECTION_TYPE extends CmsSection>(content: SECTION_TYPE): UseCmsSectionType;

/**
 *
 * Provides state for navigation trees depending on navigation type.
 */
type UseNavigationReturn = {
    /**
     * List of navigation elements
     */
    navigationElements: ComputedRef<StoreNavigationElement[] | null>;
    /**
     * Load navigation elements
     */
    loadNavigationElements(params: {
        depth: number;
    }): Promise<StoreNavigationElement[]>;
};
/**
 * Composable for navigation.
 * Provides state for navigation trees depending on navigation type.
 *
 * @example
 * ```
 * // get main navigation
 * useNavigation()
 * // get footer navigation
 * useNavigation({ type: "footer-navigation" } )
 * ```
 * @public
 * @category Navigation & Routing
 */
declare function useNavigation(params?: {
    type?: StoreNavigationType;
}): UseNavigationReturn;

/**
 * Composable to manage cart
 *
 * @public
 * @category Cart & Checkout
 */
type UseCartReturn = {
    /**
     * Add product by id and quantity
     */
    addProduct(params: {
        id: string;
        quantity?: number;
    }): Promise<Cart>;
    /**
     * Adds a promotion code to the cart
     */
    addPromotionCode(promotionCode: string): Promise<void>;
    /**
     * Lists all applied and active promotion codes
     */
    appliedPromotionCodes: ComputedRef<LineItem[]>;
    /**
     * Current Cart object
     */
    cart: ComputedRef<Cart | undefined>;
    /**
     * All items in the cart
     */
    cartItems: ComputedRef<LineItem[]>;
    /**
     * Changes the quantity of a product in the cart
     */
    changeProductQuantity(params: {
        id: string;
        quantity: number;
    }): void;
    /**
     * The number of items in the cart
     */
    count: ComputedRef<number>;
    /**
     * Refreshes the cart object and related data
     * If @param newCart is provided, it will be used as a new cart object
     */
    refreshCart(newCart?: Cart): Promise<Cart>;
    /**
     * Removes the provided LineItem from the cart
     */
    removeItem(lineItem: LineItem): Promise<void>;
    /**
     * The total price of the cart (including calculated costs like shipping)
     */
    totalPrice: ComputedRef<number>;
    /**
     * Shipping price
     */
    shippingTotal: ComputedRef<number>;
    /**
     * The total price of all cart items
     */
    subtotal: ComputedRef<number>;
    /**
     * @deprecated handle errors in your application by checking cart.errors object
     */
    cartErrors: ComputedRef<EntityError[]>;
    /**
     * @deprecated - use product related methods to fetch an item's URL instead
     */
    getProductItemsSeoUrlsData(): Promise<Partial<Product>[]>;
    /**
     * `true` if the cart contains no items
     */
    isEmpty: ComputedRef<boolean>;
    /**
     * `true` if cart contains only digital items
     */
    isVirtualCart: ComputedRef<boolean>;
};
/**
 * Cart management logic.
 *
 * Used as [Shared](https://frontends.shopware.com/framework/shared-composables.html) Composable `useCart`
 */
declare function useCartFunction(): UseCartReturn;
declare const useCart: typeof useCartFunction;

type UseCartItemReturn = {
    /**
     * Calculated price {number} for the current item
     */
    itemRegularPrice: ComputedRef<number | undefined>;
    /**
     * Calculated price {number} for the current item if list price is set
     */
    itemSpecialPrice: ComputedRef<number | undefined>;
    /**
     * Total price for the current item of given quantity in the cart
     */
    itemTotalPrice: ComputedRef<number | undefined>;
    /**
     * Thumbnail url for the current item's entity
     */
    itemImageThumbnailUrl: ComputedRef<string>;
    /**
     * Options (of variation) for the current item
     */
    itemOptions: ComputedRef<PropertyGroupOptionCart[]>;
    /**
     * Type of the current item: "product" or "promotion"
     */
    itemType: ComputedRef<LineItemType | undefined>;
    /**
     * Determines if the current item is a product
     */
    isProduct: ComputedRef<boolean>;
    /**
     * Determines if the current item is a promotion
     */
    isPromotion: ComputedRef<boolean>;
    /**
     * Stock information for the current item
     */
    itemStock: ComputedRef<number | undefined>;
    /**
     * Quantity of the current item in the cart
     */
    itemQuantity: ComputedRef<number | undefined>;
    /**
     * Changes the current item quantity in the cart
     */
    changeItemQuantity(quantity: number): Promise<void>;
    /**
     * Removes the current item from the cart
     */
    removeItem(): Promise<void>;
    /**
     * Get SEO data for the current item
     *
     * @deprecated
     */
    getProductItemSeoUrlData(): Promise<ProductResponse$1 | undefined>;
};
/**
 * Composable to manage specific cart item
 * @public
 * @category Cart & Checkout
 */
declare function useCartItem(cartItem: Ref<LineItem>): UseCartItemReturn;

type UseUserReturn = {
    /**
     * Logs-in user with given credentials
     * @param params - username and password
     *
     * @see https://github.com/shopware/frontends/issues/112 if login fails due to missing context token
     */
    login(params: {
        username: string;
        password: string;
    }): Promise<void>;
    /**
     * Registers the user for given credentials
     * @param params {@link CustomerRegistrationParams}
     * @returns {@link Customer} object on success
     */
    register(params: CustomerRegistrationParams): Promise<Customer>;
    /**
     * Whole {@link Customer} object
     */
    user: ComputedRef<Partial<Customer> | undefined>;
    /**
     * Indicates if the user is logged in
     */
    isLoggedIn: ComputedRef<boolean>;
    /**
     * Indicates if the user is logged in as a customer (not a guest)
     */
    isCustomerSession: ComputedRef<boolean>;
    /**
     * Indicates if the user is logged in as a guest
     */
    isGuestSession: ComputedRef<boolean>;
    /**
     * {@link Country} of the user
     */
    country: Ref<Country | null>;
    /**
     * {@link Salutation} of the user
     */
    salutation: Ref<Salutation | null>;
    /**
     * Default billing address id
     */
    defaultBillingAddressId: ComputedRef<string | null>;
    /**
     * Default shipping address id
     */
    defaultShippingAddressId: ComputedRef<string | null>;
    /**
     * Fetches the user data from the API
     */
    refreshUser(): Promise<void>;
    /**
     * Logs out the user
     */
    logout(): Promise<void>;
    /**
     * Loads the {@link Country} of the user
     */
    loadCountry(countryId: string): Promise<void>;
    /**
     * Loads the {@link Salutation} for given id
     */
    loadSalutation(salutationId: string): Promise<void>;
    /**
     * Updates the user profile data
     * @param personals {@link CustomerUpdateProfileParam}
     * @returns
     */
    updatePersonalInfo(personals: CustomerUpdateProfileParam): Promise<void>;
    /**
     * Updates the user email
     * @param updateEmailData - {@link CustomerUpdateEmailParam}
     * @returns
     */
    updateEmail(updateEmailData: CustomerUpdateEmailParam): Promise<void>;
    /**
     * Sets the default payment method for given id
     * @param paymentMethodId
     * @returns
     */
    setDefaultPaymentMethod(paymentMethodId: string): Promise<void>;
    /**
     * Default payment method for the user
     */
    userDefaultPaymentMethod: ComputedRef<PaymentMethodTranslation | null>;
    /**
     * Default billing address for the user
     */
    userDefaultBillingAddress: ComputedRef<BillingAddress | null>;
    /**
     * Default shipping address for the user
     */
    userDefaultShippingAddress: ComputedRef<ShippingAddress | null>;
};
/**
 * Composable for user management.
 * @public
 * @category Customer & Account
 */
declare function useUser(): UseUserReturn;

type UseSessionContextReturn = {
    /**
     * Patches the context in order to use new language
     */
    setLanguage(language: Partial<Language>): Promise<void>;
    /**
     * current context's language
     */
    sessionContext: ComputedRef<SessionContext | undefined>;
    /**
     * Fetches the session context and assigns the result to the `sessionContext` property
     */
    refreshSessionContext(): Promise<void>;
    /**
     * current context's language
     */
    selectedShippingMethod: ComputedRef<ShippingMethod | null>;
    /**
     * Patches the context in order to use new shipping method
     */
    setShippingMethod(shippingMethod: Partial<ShippingMethod>): Promise<void>;
    /**
     * current context's payment method
     */
    selectedPaymentMethod: ComputedRef<PaymentMethod | null>;
    /**
     * Patches the context in order to use new payment method
     */
    setPaymentMethod(paymentMethod: Partial<PaymentMethod>): Promise<void>;
    /**
     * current context's currency
     */
    currency: ComputedRef<Currency | null>;
    /**
     * Patches the context in order to use new currency
     */
    setCurrency(currency: Partial<Currency>): Promise<void>;
    /**
     * current context's shipping address
     */
    activeShippingAddress: ComputedRef<ShippingAddress | null>;
    /**
     * Patches the context in order to use new shipping address
     */
    setActiveShippingAddress(address: Partial<ShippingAddress>): Promise<void>;
    /**
     * current context's billing address
     */
    activeBillingAddress: ComputedRef<BillingAddress | null>;
    /**
     * current context's tax state
     */
    taxState: ComputedRef<string | null>;
    /**
     * Patches the context in order to use new billing address
     */
    setActiveBillingAddress(address: Partial<BillingAddress>): Promise<void>;
    /**
     * current context's country id
     */
    countryId: ComputedRef<string | undefined>;
    /**
     * current context's customer object
     */
    userFromContext: ComputedRef<Customer | undefined>;
};
/**
 * Composable for session management.
 * SessionContext contain all related data like user, currency, country, shippingMethod, paymentMethod etc.
 * @public
 * @category Context & Language
 */
declare function useSessionContext(newContext?: SessionContext): UseSessionContextReturn;

type UseAddToCartReturn = {
    /**
     * Add to cart method
     * @type {function}
     */
    addToCart(): Promise<Cart>;
    /**
     * If you want to add more that 1 product set quantity before invoking `addToCart`
     */
    quantity: Ref<number>;
    /**
     * Returns product count in stock
     */
    getStock: ComputedRef<number | undefined>;
    /**
     * Returns product count in available stock
     */
    getAvailableStock: ComputedRef<number | null>;
    /**
     * Flag if product is already in cart
     */
    isInCart: ComputedRef<boolean>;
    /**
     * count of the product quantity already in the cart
     */
    count: ComputedRef<number>;
};
/**
 * Composable to manage adding product to cart
 * @public
 * @category Cart & Checkout
 */
declare function useAddToCart(product: Ref<Product>): UseAddToCartReturn;

type NotificationType = "info" | "warning" | "success" | "danger";
/**
 * @private
 */
type Notification = {
    type: NotificationType;
    message: string;
    id: number;
};
/**
 * @private
 */
type NotificationOptions = {
    /**
     * @private
     */
    type?: NotificationType;
    timeout?: number;
    persistent?: boolean;
};
/**
 * @public
 */
type UseNotificationsReturn = {
    /**
     * List of active notifications
     */
    notifications: ComputedRef<Notification[]>;
    /**
     * Removes a specific notification by its ID
     */
    removeOne(id: number): void;
    /**
     * Resets the notification list - clear all notifications
     */
    removeAll(): void;
    /**
     * Push an info notification to the current list
     */
    pushInfo(message: string, options?: NotificationOptions): void;
    /**
     * Pushes a warning notification to the current list
     */
    pushWarning(message: string, options?: NotificationOptions): void;
    /**
     * Pushes an error notification to the current list
     */
    pushError(message: string, options?: NotificationOptions): void;
    /**
     * Pushes a success notification to the current list
     */
    pushSuccess(message: string, options?: NotificationOptions): void;
};
/**
 * Composable for managing notifications (flash messages) on frontend.
 * @public
 */
declare function useNotifications(): UseNotificationsReturn;

type UseLandingSearchReturn = {
    /**
     * Search for landing page by ID
     * Accepts optional media associations
     */
    search(navigationId: string, options?: {
        withCmsAssociations?: boolean;
    }): Promise<LandingPage>;
};
/**
 * Composable for landing page search.
 * @public
 * @category Navigation & Routing
 */
declare function useLandingSearch(): {
    search: (navigationId: string, options?: {
        withCmsAssociations?: boolean;
    }) => Promise<LandingPage>;
};

type ListingType = "productSearchListing" | "categoryListing";
type UseListingReturn<ELEMENTS_TYPE> = {
    /**
     * Listing that is currently set
     * {@link ListingResult} object
     */
    getInitialListing: ComputedRef<ListingResult<ELEMENTS_TYPE> | null>;
    /**
     * Sets the initial listing - available synchronously
     * @param {@link initialListing} - initial listing to set
     * @returns
     */
    setInitialListing(initialListing: Partial<ListingResult<ELEMENTS_TYPE>>): Promise<void>;
    /**
     * @deprecated - use `search` instead
     * Searches for the listing based on the criteria
     * @param criteria {@link ShopwareSearchParams}
     * @returns
     */
    initSearch(criteria: Partial<ShopwareSearchParams>): Promise<ListingResult<ELEMENTS_TYPE>>;
    /**
     * Searches for the listing based on the criteria
     * @param criteria
     * @param options - `options.preventRouteChange` - if true, the route will not be changed
     * @returns
     */
    search(criteria: Partial<ShopwareSearchParams>, options?: {
        preventRouteChange?: boolean;
    }): Promise<void>;
    /**
     * Loads more (next page) elements to the listing
     */
    loadMore(): Promise<void>;
    /**
     * Listing that is currently set
     */
    getCurrentListing: ComputedRef<Partial<ListingResult<ELEMENTS_TYPE>> | null>;
    /**
     * Listing elements ({@link Product}) that are currently set
     */
    getElements: ComputedRef<ELEMENTS_TYPE[]>;
    /**
     * Available sorting orders
     */
    getSortingOrders: ComputedRef<Sort[] | {
        key: string;
        label: string;
    }[]>;
    /**
     * Current sorting order
     */
    getCurrentSortingOrder: ComputedRef<string | undefined>;
    /**
     * Changes the current sorting order
     * @param order - i.e. "name-asc"
     * @returns
     */
    changeCurrentSortingOrder(order: string, query?: Partial<ShopwareSearchParams>): Promise<void>;
    /**
     * Current page number
     */
    getCurrentPage: ComputedRef<number>;
    /**
     * Changes the current page number
     * @param pageNumber - page number to change to
     * @returns
     */
    changeCurrentPage(page: number, query?: Partial<ShopwareSearchParams>): Promise<void>;
    /**
     * Total number of elements found for the current search criteria
     */
    getTotal: ComputedRef<number>;
    /**
     * Total number of pages found for the current search criteria
     */
    getTotalPagesCount: ComputedRef<number>;
    /**
     * Number of elements per page
     */
    getLimit: ComputedRef<number>;
    /**
     * Initial filters
     */
    getInitialFilters: ComputedRef<ListingFilter[]>;
    /**
     * All available filters
     */
    getAvailableFilters: ComputedRef<ListingFilter[]>;
    /**
     * Filters that are currently set
     */
    getCurrentFilters: ComputedRef<any>;
    /**
     * Sets the filters to be applied for the listing
     * @param filters
     * @returns
     */
    setCurrentFilters(filters: any): Promise<void>;
    /**
     * Indicates if the listing is being fetched
     */
    loading: ComputedRef<boolean>;
    /**
     * Indicates if the listing is being fetched via `loadMore` method
     */
    loadingMore: ComputedRef<boolean>;
    /**
     * Resets the filters - clears the current filters
     */
    resetFilters(): Promise<void>;
    /**
     * Change selected filters to the query object
     */
    filtersToQuery(filters: any): Record<string, any>;
};
/**
 * @public
 */
declare function useListing(params?: {
    listingType: ListingType;
    categoryId?: string;
    defaultSearchCriteria?: Partial<ShopwareSearchParams>;
}): UseListingReturn<Product>;
/**
 * Factory to create your own listing.
 *
 * By default you can use useListing composable, which provides you predefined listings for category(cms) listing and product search listing.
 * Using factory you can provide our own compatible search method and use it for example for creating listing of orders in my account.
 *
 * @public
 */
declare function createListingComposable<ELEMENTS_TYPE>({ searchMethod, searchDefaults, listingKey, }: {
    searchMethod(searchParams: Partial<ShopwareSearchParams>): Promise<ListingResult<ELEMENTS_TYPE>>;
    searchDefaults: ShopwareSearchParams;
    listingKey: string;
}): UseListingReturn<ELEMENTS_TYPE>;

type UseProductReturn = {
    /**
     * {@link Product} object
     */
    product: ComputedRef<Product>;
    /**
     * {@link PropertyGroup} array that defines the product possible configurations
     */
    configurator: ComputedRef<PropertyGroup[]>;
    /**
     * Merges the current product with the new variant data
     * @param variant - {@link Product} object with the new variant data
     */
    changeVariant(variant: Partial<Product>): void;
};
/**
 * Composable for product management.
 * @public
 * @category Product
 */
declare function useProduct(product?: Ref<Product> | Product, configurator?: Ref<PropertyGroup[]> | PropertyGroup[]): UseProductReturn;

type UseProductSearchReturn = {
    /**
     * Searches for a product by its id
     * @param productId
     * @param options - optional parameters accepts `withCmsAssociations` flag to fetch cms-related associations and criteria
     * @returns {Promise<ProductResponse>}
     */
    search: (productId: string, options?: {
        withCmsAssociations?: boolean;
        criteria?: Partial<ShopwareSearchParams>;
    }) => Promise<ProductResponse$1>;
};
/**
 * Composable for product search.
 * @public
 * @category Navigation & Routing
 */
declare function useProductSearch(): {
    search: (productId: string, options?: {
        withCmsAssociations?: boolean;
        criteria?: Partial<ShopwareSearchParams>;
    }) => Promise<ProductResponse$1>;
};

type UseCheckoutReturn = {
    /**
     * Fetches all available shipping methods
     */
    getShippingMethods(options?: {
        forceReload: boolean;
    }): Promise<ComputedRef<ShippingMethod[]>>;
    /**
     * List of available shipping methods
     */
    shippingMethods: ComputedRef<ShippingMethod[]>;
    /**
     * Fetches all available payment methods
     */
    getPaymentMethods(options?: {
        forceReload: boolean;
    }): Promise<ComputedRef<PaymentMethod[]>>;
    /**
     * List of available payment methods
     */
    paymentMethods: ComputedRef<PaymentMethod[]>;
    /**
     * Creates order based on the current cart
     */
    createOrder(params?: CreateOrderParams): Promise<Order>;
    /**
     * Shipping address for the current session
     */
    shippingAddress: ComputedRef<ShippingAddress | undefined>;
    /**
     * Billing address for the current session
     */
    billingAddress: ComputedRef<Partial<BillingAddress> | undefined>;
    /**
     * Selected shipping method for the current session
     * Sugar for {@link useSessionContext.selectedShippingMethod}
     */
    selectedShippingMethod: ComputedRef<ShippingMethod | null>;
    /**
     * Sets shipping method for the current session
     * Sugar for {@link useSessionContext.setShippingMethod}
     */
    setShippingMethod(shippingMethod: Partial<ShippingMethod>): Promise<void>;
    /**
     * Selected payment method for the current session
     * Sugar for {@link useSessionContext.selectedPaymentMethod}
     */
    selectedPaymentMethod: ComputedRef<PaymentMethod | null>;
    /**
     * Sets payment method for the current session
     * Sugar for {@link useSessionContext.setPaymentMethod}
     */
    setPaymentMethod(paymentMethod: Partial<PaymentMethod>): Promise<void>;
};
/**
 * Composable to manage checkout process
 * @public
 * @category Cart & Checkout
 */
declare function useCheckout(): UseCheckoutReturn;

type UseSalutationsReturn = {
    mountedCallback(): Promise<void>;
    /**
     * All available salutations
     */
    getSalutations: ComputedRef<Salutation[]>;
    /**
     * Fetches the salutations list and assigns the result to the `salutations` property
     */
    fetchSalutations(): Promise<void>;
};
/**
 * Composable for fetching the salutations list.
 * @public
 * @category Context & Language
 */
declare function useSalutations(): UseSalutationsReturn;

type UseCountriesReturn = {
    mountedCallback(): Promise<void>;
    getCountries: ComputedRef<Country[]>;
    fetchCountries(): Promise<void>;
};
/**
 * Composable to manage countries
 * @public
 * @category Context & Language
 */
declare function useCountries(): UseCountriesReturn;

type UseOrderDetailsReturn = {
    /**
     * {@link Order} object
     */
    order: ComputedRef<Order | undefined | null>;
    /**
     * Order status (e.g. 'open', 'cancelled')
     */
    status: ComputedRef<string | undefined>;
    /**
     * Order total price
     */
    total: ComputedRef<number | undefined>;
    /**
     * Order subtotal price for all items
     */
    subtotal: ComputedRef<number | undefined>;
    /**
     * Order shipping costs
     */
    shippingCosts: ComputedRef<number | undefined>;
    /**
     * Shipping address
     */
    shippingAddress: ComputedRef<ShippingAddress | undefined>;
    /**
     * Billing address
     */
    billingAddress: ComputedRef<BillingAddress | undefined>;
    /**
     * Basic personal details
     */
    personalDetails: ComputedRef<{
        email: string | undefined;
        firstName: string | undefined;
        lastName: string | undefined;
    }>;
    /**
     * Payment URL for external payment methods (e.g. async payment in external payment gateway)
     */
    paymentUrl: Ref<null | string>;
    /**
     * Selected shipping method
     */
    shippingMethod: ComputedRef<ShippingMethod | undefined | null>;
    /**
     * Selected payment method
     */
    paymentMethod: ComputedRef<PaymentMethod | undefined | null>;
    /**
     * Get order object including additional associations.
     * useDefaults describes what order object should look like.
     */
    loadOrderDetails(): void;
    /**
     * Handle payment for existing error.
     *
     * Pass custom success and error URLs (optionally).
     */
    handlePayment(successUrl?: string, errorUrl?: string, paymentDetails?: unknown): void;
    /**
     * Cancel an order.
     *
     * Action cannot be reverted.
     */
    cancel(): Promise<void>;
    /**
     * Changes the payment method for current cart.
     * @param paymentMethodId - ID of the payment method to be set
     * @returns
     */
    changePaymentMethod(paymentMethodId: string): Promise<void>;
    /**
     * Get media content
     *
     * @param {string} downloadId
     * @returns {Blob}
     */
    getMediaFile: (downloadId: string) => Promise<Blob>;
    /**
     * Get order documents
     * @param {string} documentId
     * @param {string} deepLinkCode
     * @returns
     */
    getDocumentFile: (documentId: string, deepLinkCode: string) => Promise<Blob>;
    /**
     * Check if order has documents
     */
    hasDocuments: ComputedRef<boolean>;
    /**
     * Get order documents
     */
    documents: ComputedRef<OrderDocument[]>;
};
/**
 * Composable for managing an existing order.
 * @public
 * @category Customer & Account
 */
declare function useOrderDetails(orderId: string, associations?: ShopwareAssociation): UseOrderDetailsReturn;

type UseOrderPaymentReturn = {
    /**
     * If the payment can be done after the order is placed
     */
    isAsynchronous: ComputedRef<boolean | undefined>;
    /**
     * Active payment transaction
     */
    activeTransaction: ComputedRef<OrderTransaction | undefined>;
    /**
     * Payment status
     */
    state: ComputedRef<StateMachineState | null | undefined>;
    paymentUrl: Ref<null | string>;
    /**
     * Payment method set for the order
     */
    paymentMethod: ComputedRef<PaymentMethod | undefined | null>;
    /**
     * Invokes the payment process for the order in the backend
     */
    handlePayment(
    /**
     * URL to redirect after successful payment
     */
    successUrl?: string, 
    /**
     * URL to redirect after failed payment
     */
    errorUrl?: string, 
    /**
     * additional payment details to provide
     */
    paymentDetails?: unknown): Promise<void | unknown>;
    /**
     * Change a payment method for the order
     */
    changePaymentMethod(paymentMethodId: string): Promise<void>;
};
/**
 * Composable for managing an existing order.
 * @public
 * @category Customer & Account
 */
declare function useOrderPayment(order: ComputedRef<Order | null | undefined>): UseOrderPaymentReturn;

type UseLocalWishlistReturn = {
    /**
     * Get wishlist products from localstorage
     */
    getWishlistProducts(): void;
    /**
     * Add product to wishlist by its id
     */
    addToWishlist(id: string): Promise<void>;
    /**
     * Remove product from wishlist by its id
     */
    removeFromWishlist(id: string): Promise<void>;
    /**
     * Remove all products from wishlist
     */
    clearWishlist(): Promise<void>;
    /**
     * List of wishlist items
     */
    items: ComputedRef<string[]>;
    /**
     * Count of wishlist items
     */
    count: ComputedRef<number>;
};
/**
 * Composable for wishlist management.
 * @public
 * @category Wishlist
 */
declare function useLocalWishlist(): UseLocalWishlistReturn;

type UseSyncWishlistReturn = {
    /**
     * Get products from wishlist
     */
    getWishlistProducts(): void;
    /**
     * Merge products with wishlist already existing in API wishlist
     */
    mergeWishlistProducts(itemsToMerge: string[]): void;
    /**
     * Add product to wishlist
     */
    addToWishlistSync(id: string): void;
    /**
     * Remove product from wishlist
     */
    removeFromWishlistSync(id: string): void;
    /**
     * Wishlist items (Product IDs)
     */
    items: ComputedRef<string[]>;
    /**
     * Wishlist items count
     */
    count: ComputedRef<number>;
};
/**
 * Composable to manage wishlist via API
 * @public
 * @category Wishlist
 */
declare function useSyncWishlist(): UseSyncWishlistReturn;

type UseProductSearchSuggestReturn = {
    /**
     * Current search term
     */
    searchTerm: Ref<string>;
    /**
     * Indicates if the search is in progress
     */
    loading: ComputedRef<boolean>;
    /**
     * Performs the search
     * @param additionalCriteria - additional search criteria of type {@link ShopwareSearchParams}
     * @returns
     */
    search(additionalCriteria?: Partial<ShopwareSearchParams>): Promise<void>;
    /**
     * Loads more products for current search criteria
     */
    loadMore(): Promise<void>;
    /**
     * Returns the product list found by the search
     */
    getProducts: ComputedRef<Product[]>;
    /**
     * Returns the total number of products found by the search
     */
    getTotal: ComputedRef<number>;
};
/**
 * Composable for product suggest search.
 * @public
 * @category Product
 */
declare function useProductSearchSuggest(): UseProductSearchSuggestReturn;

type UseCustomerPasswordReturn = {
    errors: UnwrapRef<{
        resetPassword: ShopwareError[];
        updatePassword: ShopwareError[];
    }>;
    /**
     * Change customer's current password
     */
    updatePassword(updatePasswordData: CustomerUpdatePasswordParam): Promise<boolean>;
    /**
     * Reset customer's password
     */
    resetPassword(resetPasswordData: CustomerResetPasswordParam): Promise<boolean>;
};
/**
 * Composable for customer password management.
 * @public
 * @category Customer & Account
 */
declare function useCustomerPassword(): UseCustomerPasswordReturn;

type UsePriceReturn = {
    /**
     * Set init data: localeCode & currencyCode
     */
    init(options: {
        localeCode: string | undefined;
        currencyCode: string;
    }): void;
    /**
     * Format price i.e. (2) -> 2.00 $
     */
    getFormattedPrice(value: number | string | undefined): string;
};
/**
 * Composable for getting formatted price
 * @public
 * @category Product
 */
declare function _usePrice(): UsePriceReturn;
declare const usePrice: typeof _usePrice;

type UseCustomerOrdersReturn = {
    /**
     * All placed orders belonging to the logged-in customer
     */
    orders: Ref<Order[]>;
    /**
     * Changes the current page of the orders list
     */
    changeCurrentPage(pageNumber: number | string): Promise<void>;
    /**
     * Fetches the orders list and assigns the result to the `orders` property
     */
    loadOrders(): Promise<void>;
};
/**
 * Composable for fetching the orders list.
 * @public
 * @category Customer & Account
 */
declare function useCustomerOrders(): UseCustomerOrdersReturn;

/**
 * Currently devtools are not working in Nuxt 3
 * source: https://github.com/nuxt/framework/issues/4325
 * - we don't need them for now as we do not show any significant info for now
 */

declare function createShopwareContext(app: App, options: {
    apiInstance: ShopwareApiInstance;
    enableDevtools?: boolean;
}): any;

type UseAddressReturn = {
    /**
     * List of customer addresses
     */
    customerAddresses: ComputedRef<CustomerAddress[]>;
    /**
     * Loads the addresses that are available under `customerAddresses` property
     */
    loadCustomerAddresses(): Promise<void>;
    /**
     * Allows to create new address for a current customer
     */
    createCustomerAddress(customerAddress: CustomerAddress): Promise<CustomerAddress>;
    /**
     * Allows to update existing address for a current customer
     */
    updateCustomerAddress(customerAddress: CustomerAddress): Promise<CustomerAddress>;
    /**
     * Allows to delete existing address for a current customer
     */
    deleteCustomerAddress(addressId: string): Promise<void>;
    /**
     * Sets the address for given ID as default billing address
     */
    setDefaultCustomerBillingAddress(addressId: string): Promise<string>;
    /**
     * Sets the address for given ID as default shipping address
     */
    setDefaultCustomerShippingAddress(addressId: string): Promise<string>;
};
/**
 * Composable to manage customer addresses
 *
 * @public
 *
 * @category Cart & Checkout
 */
declare function useAddress(): UseAddressReturn;

type UseProductPriceReturn = {
    /**
     * Whole calculated price object
     */
    price: ComputedRef<CalculatedPrice | undefined>;
    /**
     * Calculated price value for one selling unit
     */
    totalPrice: ComputedRef<number | undefined>;
    /**
     * Current unit price value
     */
    unitPrice: ComputedRef<number | undefined>;
    /**
     * Can be used if isListPrice is set to true
     */
    referencePrice: ComputedRef<ReferencePrice | undefined>;
    /**
     * determines if `price` contains the minimum tier price
     */
    displayFrom: ComputedRef<boolean>;
    /**
     * cheapest price value for a variant if exists
     */
    displayFromVariants: ComputedRef<number | false | undefined>;
    /**
     * array of TierPrice object
     */
    tierPrices: ComputedRef<TierPrice[]>;
    /**
     * determines whether a discount price is set
     */
    isListPrice: ComputedRef<boolean>;
};
/**
 * The purpose of the `useProductPrice` function is to abstract the logic to expose most useful helpers for price displaying.
 *
 * @public
 * @category Product
 */
declare function useProductPrice(product: Ref<Product>): UseProductPriceReturn;

type UseInternationalizationReturn = {
    /**
     * StorefrontUrl is needed to specify language of emails
     */
    getStorefrontUrl(): string;
};
/**
 * Composable for internationalization management.
 * @public
 * @category Context & Language
 */
declare function useInternationalization(): UseInternationalizationReturn;

type UseCmsMetaReturn = {
    /**
     * Meta title for current page/entity
     */
    title: ComputedRef<string>;
    /**
     * Meta tags for current page/entity
     */
    meta: ComputedRef<{
        name: string;
        content: string;
    }[]>;
};
/**
 * TODO: remove parameter and use reactive state of cmsResponse provided by useCms composable
 */
declare function useCmsMeta(entity: CmsPageEntity): UseCmsMetaReturn;

type UseNewsletterReturn = {
    /**
     * Subscribes the user to the newsletter
     * @param params {@link NewsletterInput}
     */
    newsletterSubscribe(params: NewsletterInput): Promise<void>;
    /**
     * Removes the email from the newsletter
     * @param email
     */
    newsletterUnsubscribe(email: string): Promise<void>;
    /**
     * Get newsletter status from the API call
     */
    getNewsletterStatus(): Promise<void>;
    /**
     * Indicates if the user is subscribed to the newsletter
     *
     * Returns `true` if the user is subscribed to the newsletter, `false` otherwise
     */
    isNewsletterSubscriber: ComputedRef<boolean>;
    /**
     * Newsletter status
     */
    newsletterStatus: Ref<NewsletterStatus>;
    /**
     * Inform about newsletter confirmation
     */
    confirmationNeeded: ComputedRef<boolean>;
};
declare const enum NewsletterStatus {
    NOT_SET = "notSet",
    DIRECT = "direct",
    UNDEFINED = "undefined",
    OPT_OUT = "optOut",
    OPT_IN = "optIn"
}
/**
 * Composable for newsletter subscription.
 * @public
 * @category Customer & Account
 */
declare function useNewsletter(): UseNewsletterReturn;

type UseNavigationContextReturn = {
    /**
     * SEO URL from the navigation context
     */
    navigationContext: ComputedRef<SeoUrl | null>;
    /**
     * Route name from the navigation context
     */
    routeName: ComputedRef<RouteName | undefined>;
    /**
     * Foreign key (ID) for current navigation context
     */
    foreignKey: ComputedRef<string>;
};
/**
 * Composable to get navigation context from the URL.
 * @public
 * @category Navigation & Routing
 */
declare function useNavigationContext(context?: Ref<SeoUrl | null>): UseNavigationContextReturn;

type UseNavigationSearchReturn = {
    /**
     * Get {@link SeoUrl} entity for given path
     * @example resolvePath("/my-category/my-product") or resolvePath("/") for home page
     */
    resolvePath(path: string): Promise<SeoUrl | null>;
};
/**
 * Composable to get search for SeoUrl entity for given path.
 * @public
 * @category Navigation & Routing
 */
declare function useNavigationSearch(): UseNavigationSearchReturn;

/**
 * Template composable
 */

type UseWishlistReturn = {
    /**
     * Merge products with wishlist between async (API) and sync (localstorage) wishlists
     */
    mergeWishlistProducts(): void;
    /**
     * Get products list added to wishlist
     */
    getWishlistProducts(): void;
    /**
     * Clear wishlist
     */
    clearWishlist(): void;
    /**
     * Wishlist items (Product IDs)
     */
    items: ComputedRef<string[]>;
    /**
     * Wishlist items count
     */
    count: ComputedRef<number>;
};
/**
 * Composable to manage wishlist
 * @public
 * @category Wishlist
 */
declare function useWishlist(): UseWishlistReturn;

type UseProductWishlistReturn = {
    /**
     * Removes product from wishlist
     */
    removeFromWishlist(): Promise<void>;
    /**
     * Adds product to wishlist
     */
    addToWishlist(): Promise<void>;
    /**
     * Indicates whether a product is in wishlist
     */
    isInWishlist: Ref<boolean>;
};
/**
 * Manage wishlist for a single product.
 * @public
 * @category Product
 */
declare function useProductWishlist(product: Ref<Product>): UseProductWishlistReturn;

/**
 * @internal
 */
type Breadcrumb = {
    name: string;
    path?: string;
};
/**
 * @public
 */
type UseBreadcrumbsReturn = {
    /**
     * Clear breadcrumbs store
     */
    clearBreadcrumbs(): void;
    /**
     * List of breadcrumbs
     */
    breadcrumbs: ComputedRef<Breadcrumb[]>;
};
/**
 * Composable for breadcrumbs management.
 * Read the [guide](https://frontends.shopware.com/getting-started/breadcrumbs.html#building-breadcrumbs-for-cms-pages).
 *
 * It's recommended to use [getCategoryBreadcrumbs](https://frontends.shopware.com/packages/helpers/getCategoryBreadcrumbs) for category breadcrumbs.
 *
 * @public
 * @category CMS (Shopping Experiences)
 */
declare function useBreadcrumbs(newBreadcrumbs?: Breadcrumb[]): UseBreadcrumbsReturn;

declare function resolveCmsComponent(content: CmsSection | CmsBlock | CmsSlot): {
    componentName: string;
    isResolved: boolean;
    resolvedComponent: vue.ConcreteComponent<{}, any, any, vue.ComputedOptions, vue.MethodOptions> | undefined;
    resolved?: undefined;
    error?: undefined;
} | {
    componentName: string;
    resolvedComponent: undefined;
    resolved: boolean;
    error: string;
    isResolved?: undefined;
};
declare function getDefaultApiParams(): {
    [composableName: string]: any;
};

export { BoxLayout, Breadcrumb, CATEGORY_ROUTE_NAME, CategoryResponse, CmsBlockCategoryNavigation, CmsBlockCenterText, CmsBlockCrossSelling, CmsBlockForm, CmsBlockGalleryBuybox, CmsBlockImage, CmsBlockImageBubbleRow, CmsBlockImageCover, CmsBlockImageFourColumn, CmsBlockImageGallery, CmsBlockImageHighlightRow, CmsBlockImageSimpleGrid, CmsBlockImageSlider, CmsBlockImageText, CmsBlockImageTextBubble, CmsBlockImageTextCover, CmsBlockImageTextGallery, CmsBlockImageTextRow, CmsBlockImageThreeColumn, CmsBlockImageThreeCover, CmsBlockImageTwoColumn, CmsBlockProductDescriptionReviews, CmsBlockProductHeading, CmsBlockProductListing, CmsBlockProductSlider, CmsBlockProductThreeColumn, CmsBlockSidebarFilter, CmsBlockText, CmsBlockTextHero, CmsBlockTextOnImage, CmsBlockTextTeaser, CmsBlockTextTeaserSection, CmsBlockTextThreeColumn, CmsBlockTextTwoColumn, CmsBlockVimeoVideo, CmsBlockYoutubeVideo, CmsElementBuyBox, CmsElementCategoryNavigation, CmsElementCrossSelling, CmsElementForm, CmsElementImage, CmsElementImageGallery, CmsElementImageSlider, CmsElementManufacturerLogo, CmsElementProductBox, CmsElementProductDescriptionReviews, CmsElementProductListing, CmsElementProductName, CmsElementProductSlider, CmsElementSidebarFilter, CmsElementText, CmsElementVimeoVideo, CmsElementYoutubeVideo, CmsSectionBlock, CmsSectionDefault, CmsSectionSidebar, DisplayMode, ElementConfig, LANDING_PAGE_ROUTE_NAME, LandingPageResponse, ListingType, Notification, NotificationOptions, PRODUCT_ROUTE_NAME, Position, ProductResponse, ResourceType, SearchCmsResult, ShopwareContext, SliderElementConfig, SourceType, UseAddToCartReturn, UseAddressReturn, UseBreadcrumbsReturn, UseCartItemReturn, UseCartReturn, UseCategoryReturn, UseCategorySearchReturn, UseCheckoutReturn, UseCmsBlockReturn, UseCmsElementImage, UseCmsMetaReturn, UseCountriesReturn, UseCustomerOrdersReturn, UseCustomerPasswordReturn, UseInternationalizationReturn, UseLandingSearchReturn, UseListingReturn, UseLocalWishlistReturn, UseNavigationContextReturn, UseNavigationReturn, UseNavigationSearchReturn, UseNewsletterReturn, UseNotificationsReturn, UseOrderDetailsReturn, UseOrderPaymentReturn, UsePriceReturn, UseProductAssociationsReturn, UseProductConfiguratorReturn, UseProductPriceReturn, UseProductReturn, UseProductReviewsReturn, UseProductSearchReturn, UseProductSearchSuggestReturn, UseProductWishlistReturn, UseSalutationsReturn, UseSessionContextReturn, UseSyncWishlistReturn, UseUserReturn, UseWishlistReturn, VerticalAlign, createListingComposable, createShopwareContext, getDefaultApiParams, resolveCmsComponent, useAddToCart, useAddress, useBreadcrumbs, useCart, useCartFunction, useCartItem, useCategory, useCategorySearch, useCheckout, useCmsBlock, useCmsElementConfig, useCmsElementImage, useCmsMeta, useCmsSection, useCountries, useCustomerOrders, useCustomerPassword, useInternationalization, useLandingSearch, useListing, useLocalWishlist, useNavigation, useNavigationContext, useNavigationSearch, useNewsletter, useNotifications, useOrderDetails, useOrderPayment, usePrice, useProduct, useProductAssociations, useProductConfigurator, useProductPrice, useProductReviews, useProductSearch, useProductSearchSuggest, useProductWishlist, useSalutations, useSessionContext, useShopwareContext, useSyncWishlist, useUser, useWishlist };
