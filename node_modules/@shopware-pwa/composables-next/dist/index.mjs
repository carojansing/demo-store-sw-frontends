import { pascalCase } from 'scule';
import { computed, inject, ref, unref, provide, onMounted, reactive, effectScope, markRaw, resolveComponent } from 'vue';
import { getSrcSetForMedia, getTranslatedProperty, getMainImageUrl, getListingFilters, getProductTierPrices } from '@shopware-pwa/helpers-next';
import { invokePost, getCategoryDetailsEndpoint, getProductEndpoint, getProductReviews, addProductReview, invokeGet, getProductDetailsEndpoint, getStoreNavigation, getCart, addProductToCart, removeCartItem, changeCartItemQuantity, addPromotionCode, getProducts, getProduct, login, register, logout, getCustomer, getUserCountry, getUserSalutation, updateProfile, updateEmail, setDefaultCustomerPaymentMethod, getSessionContext, setCurrentShippingMethod, setCurrentPaymentMethod, setCurrentCurrency, setCurrentLanguage, setCurrentShippingAddress, setCurrentBillingAddress, getLandingPage, searchProducts, getCategoryProducts, getAvailableShippingMethods, getAvailablePaymentMethods, createOrder, getAvailableSalutations, getAvailableCountries, getOrderDetails, handlePayment, cancelOrder, changeOrderPaymentMethod, getOrderDownloads, getDocumentDownload, addWishlistProduct, removeWishlistProduct, getWishlistProducts, mergeWishlistProducts, updatePassword, resetPassword, getCustomerOrders, getCustomerAddresses, createCustomerAddress, updateCustomerAddress, deleteCustomerAddress, setDefaultCustomerBillingAddress, setDefaultCustomerShippingAddress, newsletterSubscribe, newsletterUnsubscribe, isNewsletterSubscriber, getSeoUrl } from '@shopware-pwa/api-client';
import { createSharedComposable, syncRefs } from '@vueuse/core';

const PRODUCT_ROUTE_NAME = "frontend.detail.page";
const CATEGORY_ROUTE_NAME = "frontend.navigation.page";
const LANDING_PAGE_ROUTE_NAME = "frontend.landing.page";

function useCmsElementImage(element) {
  const { getConfigValue } = useCmsElementConfig(element);
  const containerStyle = computed(() => ({
    minHeight: getConfigValue("minHeight")
  }));
  const anchorAttrs = computed(() => ({
    href: getConfigValue("url"),
    target: getConfigValue("newTab") ? "_blank" : "_self"
  }));
  const imageLink = computed(() => ({
    newTab: element.data?.newTab,
    url: element.data?.url
  }));
  const imageContainerAttrs = computed(() => {
    const attr = {};
    if (imageLink.value.url) {
      attr.href = imageLink.value.url;
    }
    if (imageLink.value.newTab) {
      attr.target = "blank";
      attr.rel = "noopener noreferrer";
    }
    return attr;
  });
  const imageAttrs = computed(() => ({
    src: element.data?.media?.url,
    alt: element.data?.media?.alt || "",
    srcset: getSrcSetForMedia(element.data?.media)
  }));
  const displayMode = computed(
    () => getConfigValue("displayMode") || "initial"
  );
  return {
    containerStyle,
    anchorAttrs,
    imageAttrs,
    imageContainerAttrs,
    imageLink,
    displayMode
  };
}

function useCmsElementConfig(element) {
  const getConfigValue = (key) => {
    return element.config[key]?.source !== "mapped" && element.config[key]?.value;
  };
  return {
    getConfigValue
  };
}

class ContextError extends Error {
  constructor(scope, message) {
    super(`${scope} ${message ? message : "context is not provided"}`);
    this.name = "ContextError";
  }
}

function useShopwareContext() {
  const shopwareContext = inject("shopware", null);
  if (!shopwareContext)
    throw new ContextError("Shopware");
  return {
    apiInstance: shopwareContext.apiInstance
  };
}

function _useContext(injectionName, params) {
  const isNewContext = !!params?.context;
  const _context = isNewContext ? ref(unref(params?.context)) : inject(injectionName, ref());
  provide(injectionName, _context);
  if (!!params?.replace) {
    _context.value = unref(params.replace);
  }
  return _context;
}

function useCategory(category) {
  const _category = _useContext("category", { context: category });
  if (!_category.value) {
    throw new ContextError("Category");
  }
  return {
    category: computed(() => _category.value)
  };
}

const cmsAssociations = {
  associations: {
    media: {},
    cmsPage: {
      associations: {
        sections: {
          associations: {
            blocks: {
              associations: {
                slots: {
                  associations: {
                    block: {
                      associations: {
                        slots: {
                          associations: {}
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

function useCategorySearch() {
  const { apiInstance } = useShopwareContext();
  async function search(categoryId, options) {
    const associations = options?.withCmsAssociations ? cmsAssociations : {};
    const result = await invokePost(
      {
        address: getCategoryDetailsEndpoint(categoryId),
        payload: { associations, ...options?.query }
      },
      apiInstance
    );
    return result.data;
  }
  return {
    search
  };
}

function useProductConfigurator() {
  const { apiInstance } = useShopwareContext();
  const { configurator, product } = useProduct();
  if (!product.value) {
    throw new Error(
      "Product configurator cannot be used without the product context."
    );
  }
  const selected = ref({});
  const isLoadingOptions = ref(!!product.value.options?.length);
  const parentProductId = computed(() => product.value?.parentId);
  const getOptionGroups = computed(() => {
    return configurator.value || [];
  });
  const findGroupCodeForOption = (optionId) => {
    const group = getOptionGroups.value.find((optionGroup) => {
      const optionFound = optionGroup.options?.find(
        (option) => option.id === optionId
      );
      return !!optionFound;
    });
    return getTranslatedProperty(group, "name");
  };
  product.value.optionIds?.forEach((optionId) => {
    const optionGroupCode = findGroupCodeForOption(optionId);
    if (optionGroupCode) {
      selected.value[optionGroupCode] = optionId;
    }
  });
  async function findVariantForSelectedOptions(options) {
    const filter = [
      {
        type: "equals",
        field: "parentId",
        value: parentProductId.value
      },
      ...Object.values(options || selected.value).map((id) => ({
        type: "equals",
        field: "optionIds",
        value: id
      }))
    ];
    try {
      if (apiInstance) {
        apiInstance.defaults.headers.common["sw-include-seo-urls"] = "true";
      }
      const response = await invokePost(
        {
          address: getProductEndpoint(),
          payload: {
            limit: 1,
            filter,
            includes: {
              product: ["id", "translated", "productNumber", "seoUrls"],
              seo_url: ["seoPathInfo"]
            },
            associations: {
              seoUrls: {}
            }
          }
        },
        apiInstance
      );
      return response?.data?.elements?.[0];
    } catch (e) {
      console.error("SwProductDetails:findVariantForSelectedOptions", e);
    }
  }
  const handleChange = async (group, option, onChangeHandled) => {
    selected.value = Object.assign({}, selected.value, {
      [group]: option
    });
    if (typeof onChangeHandled === "function") {
      await onChangeHandled();
    }
  };
  return {
    handleChange,
    findVariantForSelectedOptions,
    isLoadingOptions,
    getOptionGroups,
    getSelectedOptions: selected
  };
}

function useProductReviews(product) {
  const { apiInstance } = useShopwareContext();
  const productReviews = ref([]);
  const loadProductReviews = async (parameters = {}) => {
    const fetchedReviews = await getProductReviews(
      product.value.id,
      void 0,
      // Object.assign({}, getDefaults(), parameters),
      apiInstance
    );
    productReviews.value = fetchedReviews.elements ?? [];
  };
  const addReview = async (data) => {
    await addProductReview(product.value.id, data, apiInstance);
  };
  return {
    productReviews: computed(() => productReviews.value),
    loadProductReviews,
    addReview
  };
}

function useProductAssociations(product, options) {
  if (!product.value)
    throw new Error("[useProductAssociations]: Product is not provided.");
  const association = options.associationContext;
  const { apiInstance } = useShopwareContext();
  const isLoading = ref(false);
  const associations = ref([]);
  const loadAssociations = async (params) => {
    isLoading.value = true;
    const method = params.method || "get";
    try {
      if (method && method === "get") {
        const response2 = await invokeGet(
          {
            address: `${getProductDetailsEndpoint(
              product.value.id
            )}/${association}${params.searchParams || ""}`
          },
          apiInstance
        );
        associations.value = response2?.data;
        return;
      }
      const response = await invokePost(
        {
          address: `${getProductDetailsEndpoint(
            product.value.id
          )}/${association}`,
          payload: params?.searchParams || {}
        },
        apiInstance
      );
      associations.value = response?.data;
    } catch (error) {
      console.error(
        "[useProductAssociations][loadAssociations][error]:",
        error
      );
    } finally {
      isLoading.value = false;
    }
  };
  return {
    isLoading: computed(() => isLoading.value),
    productAssociations: computed(() => associations.value || []),
    loadAssociations
  };
}

function useCmsBlock(content) {
  function getSlotContent(slotName) {
    return content.slots.find((slot) => slot.slot === slotName);
  }
  return {
    block: content,
    getSlotContent
  };
}

function useCmsSection(content) {
  function getPositionContent(position) {
    return content.blocks.filter(
      (block) => block.sectionPosition === position
    );
  }
  return {
    section: content,
    getPositionContent
  };
}

function useNavigation(params) {
  const type = params?.type || "main-navigation";
  const { apiInstance } = useShopwareContext();
  const sharedElements = inject(
    `swNavigation-${type}`,
    ref([])
  );
  provide(`swNavigation-${type}`, sharedElements);
  const navigationElements = computed(() => sharedElements.value);
  async function loadNavigationElements({ depth }) {
    try {
      const navigationResponse = await getStoreNavigation(
        {
          requestActiveId: type,
          requestRootId: type,
          searchCriteria: {
            // includes: getIncludesConfig(),
            // associations: getAssociationsConfig(),
          },
          depth
        },
        apiInstance
      );
      sharedElements.value = navigationResponse || [];
      return sharedElements.value;
    } catch (e) {
      sharedElements.value = [];
      console.error("[useNavigation][loadNavigationElements]", e);
      return [];
    }
  }
  return {
    navigationElements,
    loadNavigationElements
  };
}

function useCartFunction() {
  const { apiInstance } = useShopwareContext();
  const _storeCart = _useContext("swCart");
  async function refreshCart(newCart) {
    if (newCart) {
      _storeCart.value = newCart;
      return newCart;
    }
    const result = await getCart(apiInstance);
    _storeCart.value = result;
    return result;
  }
  async function addProduct(params) {
    const addToCartResult = await addProductToCart(
      params.id,
      params.quantity,
      apiInstance
    );
    _storeCart.value = addToCartResult;
    return addToCartResult;
  }
  async function removeItem(lineItem) {
    const result = await removeCartItem(lineItem.id, apiInstance);
    _storeCart.value = result;
  }
  async function changeProductQuantity(params) {
    const result = await changeCartItemQuantity(
      params.id,
      params.quantity,
      apiInstance
    );
    _storeCart.value = result;
  }
  async function submitPromotionCode(promotionCode) {
    if (promotionCode) {
      const result = await addPromotionCode(promotionCode, apiInstance);
      _storeCart.value = result;
    }
  }
  async function getProductItemsSeoUrlsData() {
    if (!cartItems.value.length) {
      return [];
    }
    const result = await getProducts(
      {
        ids: cartItems.value.map(({ referencedId }) => referencedId).filter(String)
        // includes: (getDefaults() as any).getProductItemsSeoUrlsData.includes,
        // associations: (getDefaults() as any).getProductItemsSeoUrlsData
        //   .associations,
      },
      apiInstance
    );
    return result?.elements || [];
  }
  const appliedPromotionCodes = computed(() => {
    return cartItems.value.filter(
      (cartItem) => cartItem.type === "promotion"
    );
  });
  const cart = computed(() => _storeCart.value);
  const cartItems = computed(() => {
    return cart.value ? cart.value.lineItems || [] : [];
  });
  const count = computed(() => {
    return cartItems.value.reduce(
      (accumulator, lineItem) => lineItem.type === "product" ? lineItem.quantity + accumulator : accumulator,
      0
    );
  });
  const isEmpty = computed(() => count.value <= 0);
  const totalPrice = computed(() => {
    const cartPrice = cart.value && cart.value.price && cart.value.price.totalPrice;
    return cartPrice || 0;
  });
  const shippingTotal = computed(() => {
    const shippingTotal2 = cart.value?.deliveries?.[0]?.shippingCosts?.totalPrice;
    return shippingTotal2 || 0;
  });
  const subtotal = computed(() => {
    const cartPrice = cart.value?.price?.positionPrice;
    return cartPrice || 0;
  });
  const cartErrors = computed(
    () => cart.value?.errors && Object.values(cart.value.errors) || []
  );
  const isVirtualCart = computed(() => {
    return cartItems.value.length > 0 && cartItems.value.filter((element) => element.type !== "promotion").every((item) => item.states.includes("is-download"));
  });
  return {
    addProduct,
    addPromotionCode: submitPromotionCode,
    appliedPromotionCodes,
    cart,
    cartItems,
    changeProductQuantity,
    count,
    refreshCart,
    removeItem,
    totalPrice,
    shippingTotal,
    subtotal,
    cartErrors,
    getProductItemsSeoUrlsData,
    isEmpty,
    isVirtualCart
  };
}
const useCart = createSharedComposable(useCartFunction);

function useCartItem(cartItem) {
  if (!cartItem) {
    throw new Error("[useCartItem] mandatory cartItem argument is missing.");
  }
  const { apiInstance } = useShopwareContext();
  const { refreshCart, changeProductQuantity } = useCart();
  const itemQuantity = computed(() => cartItem.value.quantity);
  const itemImageThumbnailUrl = computed(() => getMainImageUrl(cartItem.value));
  const itemRegularPrice = computed(
    () => cartItem.value?.price?.listPrice?.price || cartItem.value?.price?.unitPrice
  );
  const itemSpecialPrice = computed(
    () => cartItem.value?.price?.listPrice?.price && cartItem.value?.price?.unitPrice
  );
  const itemTotalPrice = computed(() => cartItem.value.price?.totalPrice);
  const itemOptions = computed(
    () => cartItem.value.type === "product" && cartItem.value.payload?.options || []
  );
  const itemStock = computed(() => cartItem.value.deliveryInformation?.stock);
  const itemType = computed(() => cartItem.value.type);
  const isProduct = computed(() => cartItem.value.type === "product");
  const isPromotion = computed(() => cartItem.value.type === "promotion");
  async function removeItem() {
    const newCart = await removeCartItem(cartItem.value.id, apiInstance);
    await refreshCart(newCart);
  }
  async function changeItemQuantity(quantity) {
    await changeProductQuantity({
      id: cartItem.value.id,
      quantity
    });
  }
  async function getProductItemSeoUrlData() {
    if (!cartItem.value.referencedId) {
      return;
    }
    try {
      const result = await getProduct(
        cartItem.value.referencedId,
        {
          // includes: (getDefaults() as any).getProductItemsSeoUrlsData.includes,
          // associations: (getDefaults() as any).getProductItemsSeoUrlsData
          //   .associations,
        },
        apiInstance
      );
      return result.product;
    } catch (error) {
      console.error(
        "[useCart][getProductItemsSeoUrlsData]",
        error.messages
      );
    }
    return;
  }
  return {
    changeItemQuantity,
    removeItem,
    getProductItemSeoUrlData,
    itemRegularPrice,
    itemSpecialPrice,
    itemTotalPrice,
    itemOptions,
    itemStock,
    itemQuantity,
    itemType,
    itemImageThumbnailUrl,
    isProduct,
    isPromotion
  };
}

function useUser() {
  const { apiInstance } = useShopwareContext();
  const { userFromContext, refreshSessionContext } = useSessionContext();
  const _user = _useContext("customer");
  syncRefs(userFromContext, _user, {
    immediate: true
  });
  const { getStorefrontUrl } = useInternationalization();
  const { refreshCart } = useCart();
  const userDefaultPaymentMethod = computed(
    () => user.value?.defaultPaymentMethod?.translated || null
  );
  const userDefaultBillingAddress = computed(
    () => user.value?.defaultBillingAddress || null
  );
  const userDefaultShippingAddress = computed(
    () => user.value?.defaultShippingAddress || null
  );
  const country = ref(null);
  const salutation = ref(null);
  const user = computed(() => _user.value);
  async function login$1({
    username,
    password
  } = {}) {
    await login({ username, password }, apiInstance);
    await refreshSessionContext();
    refreshCart();
  }
  async function register$1(params) {
    const customer = await register(
      { ...params, storefrontUrl: getStorefrontUrl() },
      apiInstance
    );
    _user.value = customer;
    if (_user.value?.active)
      await refreshSessionContext();
    return customer;
  }
  async function logout$1() {
    await logout(apiInstance);
    await refreshSessionContext();
    refreshCart();
  }
  async function refreshUser(params = {}) {
    try {
      const user2 = await getCustomer(
        Object.assign(
          {},
          // getDefaults(),
          params
        ),
        apiInstance
      );
      _user.value = user2;
    } catch (e) {
      _user.value = void 0;
      console.error("[useUser][refreshUser]", e);
    }
  }
  async function loadCountry(userId) {
    country.value = await getUserCountry(userId, apiInstance);
  }
  async function loadSalutation(salutationId) {
    salutation.value = await getUserSalutation(salutationId, apiInstance);
  }
  async function updatePersonalInfo(personals) {
    await updateProfile(personals, apiInstance);
  }
  async function updateEmail$1(updateEmailData) {
    await updateEmail(updateEmailData, apiInstance);
  }
  async function setDefaultPaymentMethod(paymentMethodId) {
    await setDefaultCustomerPaymentMethod(paymentMethodId, apiInstance);
  }
  const defaultBillingAddressId = computed(
    () => user.value?.defaultBillingAddressId || null
  );
  const defaultShippingAddressId = computed(
    () => user.value?.defaultShippingAddressId || null
  );
  const isLoggedIn = computed(
    () => !!user.value?.id && !!user.value.active && !user.value.guest
  );
  const isCustomerSession = computed(
    () => !!user.value?.id && !user.value.guest
  );
  const isGuestSession = computed(() => !!user.value?.guest);
  return {
    login: login$1,
    register: register$1,
    user,
    isLoggedIn,
    isCustomerSession,
    isGuestSession,
    refreshUser,
    logout: logout$1,
    updateEmail: updateEmail$1,
    updatePersonalInfo,
    setDefaultPaymentMethod,
    loadSalutation,
    salutation,
    loadCountry,
    country,
    defaultBillingAddressId,
    defaultShippingAddressId,
    userDefaultPaymentMethod,
    userDefaultBillingAddress,
    userDefaultShippingAddress
  };
}

function _usePrice() {
  const currencyLocale = ref("");
  const currencyCode = ref("");
  function init(params) {
    _setCurrencyCode(params.currencyCode);
    _setLocaleCode(
      params.localeCode || typeof navigator !== "undefined" && navigator?.language || "en-US"
    );
  }
  function _setCurrencyCode(code) {
    currencyCode.value = code;
  }
  function _setLocaleCode(locale) {
    currencyLocale.value = locale;
  }
  function getFormattedPrice(value) {
    if (typeof value === "undefined") {
      return "";
    }
    if (!currencyLocale.value) {
      return value.toString();
    }
    return new Intl.NumberFormat(currencyLocale.value, {
      style: "currency",
      currency: currencyCode.value
    }).format(+value);
  }
  return {
    init,
    getFormattedPrice
  };
}
const usePrice = createSharedComposable(_usePrice);

function useSessionContext(newContext) {
  const { apiInstance } = useShopwareContext();
  const { init } = usePrice();
  if (newContext) {
    init({
      currencyCode: newContext.currency?.isoCode,
      localeCode: newContext.salesChannel?.language?.locale?.code
    });
  }
  const _sessionContext = _useContext("swSessionContext", {
    replace: newContext
  });
  const sessionContext = computed(() => _sessionContext.value);
  const refreshSessionContext = async () => {
    try {
      const context = await getSessionContext(apiInstance);
      _sessionContext.value = context;
      init({
        currencyCode: context.currency?.isoCode,
        localeCode: context.salesChannel?.language?.locale?.code
      });
    } catch (e) {
      console.error("[UseSessionContext][refreshSessionContext]", e);
    }
  };
  const selectedShippingMethod = computed(
    () => sessionContext.value?.shippingMethod || null
  );
  const setShippingMethod = async (shippingMethod = {}) => {
    if (!shippingMethod?.id) {
      throw new Error(
        "You need to provide shipping method id in order to set shipping method."
      );
    }
    await setCurrentShippingMethod(shippingMethod.id, apiInstance);
    await refreshSessionContext();
  };
  const selectedPaymentMethod = computed(
    () => sessionContext.value?.paymentMethod || null
  );
  const setPaymentMethod = async (paymentMethod = {}) => {
    if (!paymentMethod?.id) {
      throw new Error(
        "You need to provide payment method id in order to set payment method."
      );
    }
    await setCurrentPaymentMethod(paymentMethod.id, apiInstance);
    await refreshSessionContext();
  };
  const currency = computed(() => sessionContext.value?.currency || null);
  const setCurrency = async (currency2 = {}) => {
    if (!currency2.id) {
      console.error(
        "You need to provide currency id in order to set currency.",
        currency2
      );
      return;
    }
    await setCurrentCurrency(currency2.id, apiInstance);
    await refreshSessionContext();
  };
  const setLanguage = async (language = {}) => {
    if (!language.id) {
      return;
    }
    await setCurrentLanguage(language.id, apiInstance);
    await refreshSessionContext();
  };
  const activeShippingAddress = computed(
    () => sessionContext.value?.customer?.activeShippingAddress || null
  );
  const setActiveShippingAddress = async (address) => {
    if (!address?.id) {
      throw new Error(
        "You need to provide address id in order to set the address."
      );
    }
    await setCurrentShippingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const activeBillingAddress = computed(
    () => sessionContext.value?.customer?.activeBillingAddress || null
  );
  const setActiveBillingAddress = async (address) => {
    if (!address?.id) {
      throw new Error(
        "You need to provide address id in order to set the address."
      );
    }
    await setCurrentBillingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const countryId = computed(
    () => sessionContext.value?.salesChannel?.countryId
  );
  const taxState = computed(() => sessionContext.value?.context?.taxState);
  const userFromContext = computed(() => sessionContext.value?.customer);
  return {
    sessionContext,
    refreshSessionContext,
    selectedShippingMethod,
    setShippingMethod,
    selectedPaymentMethod,
    setPaymentMethod,
    currency,
    setCurrency,
    activeShippingAddress,
    setActiveShippingAddress,
    activeBillingAddress,
    setActiveBillingAddress,
    countryId,
    taxState,
    userFromContext,
    setLanguage
  };
}

function useAddToCart(product) {
  const _product = computed(() => unref(product));
  const { addProduct, cartItems } = useCart();
  const quantity = ref(1);
  async function addToCart() {
    if (!quantity.value)
      quantity.value = 1;
    const addToCartResponse = await addProduct({
      id: _product.value.id,
      quantity: quantity.value
    });
    quantity.value = 1;
    return addToCartResponse;
  }
  const getStock = computed(() => _product.value?.stock);
  const getAvailableStock = computed(() => _product.value?.availableStock);
  const isInCart = computed(
    () => cartItems.value.some(
      (item) => item.referencedId === _product.value?.id
    )
  );
  return {
    addToCart,
    quantity,
    getStock,
    getAvailableStock,
    isInCart,
    count: computed(
      () => cartItems.value.find(
        (item) => item.referencedId === _product.value?.id
      )?.quantity || 0
    )
  };
}

function useNotifications() {
  const _notifications = inject(
    "swNotifications",
    ref([])
  );
  provide("swNotifications", _notifications);
  function removeOne(notificationId) {
    _notifications.value = _notifications.value?.filter(({ id }) => id !== notificationId) || [];
  }
  function removeAll() {
    _notifications.value = [];
  }
  function geterateId() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  async function pushNotification(message, options) {
    const timeout = options.timeout || 2500;
    const persistent = !!options.persistent;
    _notifications.value = _notifications.value || [];
    const messageId = geterateId();
    _notifications.value.push({
      id: messageId,
      type: options.type || "info",
      message
    });
    if (!persistent) {
      setTimeout(() => {
        removeOne(messageId);
      }, timeout);
    }
  }
  return {
    removeOne,
    removeAll,
    pushInfo: (message, options = {}) => pushNotification(message, { ...options, type: "info" }),
    pushSuccess: (message, options = {}) => pushNotification(message, { ...options, type: "success" }),
    pushWarning: (message, options = {}) => pushNotification(message, { ...options, type: "warning" }),
    pushError: (message, options = {}) => pushNotification(message, { ...options, type: "danger" }),
    notifications: computed(() => _notifications.value || [])
  };
}

function useLandingSearch() {
  const { apiInstance } = useShopwareContext();
  const search = async (navigationId, options) => {
    const associations = options?.withCmsAssociations && cmsAssociations;
    const result = await getLandingPage(
      navigationId,
      associations || {},
      apiInstance
    );
    return result;
  };
  return {
    search
  };
}

function isObject$1(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function merge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (source === void 0) {
    return target;
  }
  if (isObject$1(target) && isObject$1(source)) {
    for (const key in source) {
      if (isObject$1(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        merge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return merge(target, ...sources);
}
function useListing(params) {
  const listingType = params?.listingType || "categoryListing";
  const { apiInstance } = useShopwareContext();
  let searchMethod;
  if (listingType === "productSearchListing") {
    searchMethod = async (searchCriteria) => {
      return searchProducts(searchCriteria, apiInstance);
    };
  } else {
    let resourceId;
    try {
      const { category } = useCategory();
      resourceId = category.value?.id;
    } catch (error) {
      if (error instanceof ContextError) {
        resourceId = params?.categoryId;
      } else {
        console.error(error);
      }
    }
    searchMethod = async (searchCriteria) => {
      if (!resourceId) {
        throw new Error(
          "[useListing][search] Search category id does not exist."
        );
      }
      return getCategoryProducts(resourceId, searchCriteria, apiInstance);
    };
  }
  return createListingComposable({
    listingKey: listingType,
    searchMethod,
    searchDefaults: params?.defaultSearchCriteria || {}
    //getDefaults(),
  });
}
function createListingComposable({
  searchMethod,
  searchDefaults,
  listingKey
}) {
  const loading = ref(false);
  const loadingMore = ref(false);
  const _storeInitialListing = inject(`useListingInitial-${listingKey}`, ref());
  provide(`useListingInitial-${listingKey}`, _storeInitialListing);
  const _storeAppliedListing = inject(`useListingApplied-${listingKey}`, ref());
  provide(`useListingApplied-${listingKey}`, _storeAppliedListing);
  const getInitialListing = computed(() => _storeInitialListing.value);
  const setInitialListing = async (initialListing) => {
    if (initialListing?.currentFilters?.manufacturer?.length || initialListing?.currentFilters?.properties?.length) {
      loading.value = true;
      const allFiltersResult = await searchMethod({
        query: initialListing.currentFilters.search || void 0
      });
      initialListing = Object.assign({}, initialListing, {
        aggregations: allFiltersResult?.aggregations
      });
    }
    _storeInitialListing.value = initialListing;
    _storeAppliedListing.value = null;
    loading.value = false;
  };
  const initSearch = async (criteria) => {
    loading.value = true;
    try {
      const searchCriteria = merge({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      return result;
      await setInitialListing(result);
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  async function search(criteria, options) {
    loading.value = true;
    try {
      const searchCriteria = merge({}, searchDefaults, criteria);
      const [result, allFiltersResult] = await Promise.all([
        searchMethod(searchCriteria),
        searchMethod({
          query: searchCriteria.query,
          includes: { product_listing: ["aggregations"] }
        })
      ]);
      _storeAppliedListing.value = Object.assign({}, result, {
        aggregations: Object.assign(
          {},
          result?.aggregations,
          allFiltersResult?.aggregations
        )
      });
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  }
  const loadMore = async () => {
    loadingMore.value = true;
    try {
      const query = {
        // ...router.currentRoute.query,
        p: getCurrentPage.value + 1
      };
      const searchCriteria = merge({}, searchDefaults, query);
      const result = await searchMethod(searchCriteria);
      _storeAppliedListing.value = {
        ...getCurrentListing.value,
        page: result.page,
        elements: [
          ...getCurrentListing.value?.elements || [],
          ...result.elements
        ]
      };
    } catch (e) {
      throw e;
    } finally {
      loadingMore.value = false;
    }
  };
  const getCurrentListing = computed(() => {
    return _storeAppliedListing.value || getInitialListing.value;
  });
  const getElements = computed(() => {
    return getCurrentListing.value?.elements || [];
  });
  const getTotal = computed(() => {
    return getCurrentListing.value?.total || 0;
  });
  const getLimit = computed(() => {
    return getCurrentListing.value?.limit || searchDefaults?.limit || 10;
  });
  const getTotalPagesCount = computed(
    () => Math.ceil(getTotal.value / getLimit.value)
  );
  const getSortingOrders = computed(() => {
    const oldSortings = Object.values(getCurrentListing.value?.sortings || {});
    return getCurrentListing.value?.availableSortings || oldSortings;
  });
  const getCurrentSortingOrder = computed(
    () => getCurrentListing.value?.sorting
  );
  async function changeCurrentSortingOrder(order, query) {
    await search(
      Object.assign(
        {
          order
        },
        query || {}
      )
    );
  }
  const getCurrentPage = computed(() => getCurrentListing.value?.page || 1);
  const changeCurrentPage = async (page, query) => {
    await search(
      Object.assign(
        {
          p: page
        },
        query || {}
      )
    );
  };
  const getInitialFilters = computed(() => {
    return getListingFilters(getInitialListing.value?.aggregations);
  });
  const getAvailableFilters = computed(() => {
    return getListingFilters(
      _storeAppliedListing.value?.aggregations || getCurrentListing.value?.aggregations
    );
  });
  const getCurrentFilters = computed(() => {
    const currentFiltersResult = [];
    const currentFilters = {
      ...getCurrentListing.value?.currentFilters
      // ...router.currentRoute.query,
    };
    Object.keys(currentFilters).forEach((objectKey) => {
      if (!currentFilters[objectKey])
        return;
      if (objectKey === "navigationId")
        return;
      if (objectKey === "price") {
        if (currentFilters[objectKey].min)
          currentFiltersResult["min-price"] = currentFilters[objectKey].min;
        if (currentFilters[objectKey].max)
          currentFiltersResult["max-price"] = currentFilters[objectKey].max;
        return;
      }
      if (objectKey === "p")
        return;
      currentFiltersResult[objectKey] = currentFilters[objectKey];
    });
    return currentFiltersResult;
  });
  const setCurrentFilters = (filter) => {
    const appliedFilters = Object.assign({}, getCurrentFilters.value, filter, {
      query: getCurrentFilters.value.search
    });
    _storeAppliedListing.value.currentFilters = appliedFilters;
    return search(appliedFilters);
  };
  const resetFilters = () => {
    const defaultFilters = Object.assign(
      {
        manufacturer: [],
        properties: [],
        price: { min: 0, max: 0 },
        search: getCurrentFilters.value.search
      },
      searchDefaults
    );
    _storeAppliedListing.value.currentFilters = defaultFilters;
    return search({ query: getCurrentFilters.value.search });
  };
  const filtersToQuery = (filters) => {
    let queryObject = {};
    for (const filter in filters) {
      if (filters[filter]) {
        if (Array.isArray(filters[filter]) && filters[filter].length) {
          queryObject[filter] = filters[filter].join("|");
        } else if (!Array.isArray(filters[filter])) {
          queryObject[filter] = filters[filter];
        }
      }
    }
    return queryObject;
  };
  return {
    getInitialListing,
    setInitialListing,
    initSearch,
    search,
    getCurrentListing,
    getElements,
    getSortingOrders,
    getCurrentSortingOrder,
    changeCurrentSortingOrder,
    getCurrentPage,
    changeCurrentPage,
    getTotal,
    getTotalPagesCount,
    getLimit,
    getInitialFilters,
    getAvailableFilters,
    getCurrentFilters,
    setCurrentFilters,
    loading: computed(() => loading.value),
    loadMore,
    loadingMore: computed(() => loadingMore.value),
    resetFilters,
    filtersToQuery
  };
}

function useProduct(product, configurator) {
  const _product = _useContext("product", { context: product });
  if (!_product.value) {
    throw new ContextError("Product");
  }
  const _configurator = _useContext("configurator", {
    context: product && configurator
  });
  function changeVariant(variant) {
    _product.value = Object.assign({}, _product.value, variant);
  }
  return {
    product: computed(() => _product.value),
    configurator: computed(() => _configurator.value),
    changeVariant
  };
}

function isObject(object) {
  return object && typeof object === "object" && !Array.isArray(object);
}
function deepMerge(obj1, obj2) {
  const output = Object.assign({}, obj1);
  if (isObject(obj1) && isObject(obj2)) {
    Object.keys(obj2).forEach((key) => {
      if (isObject(obj2[key])) {
        if (!(key in obj1))
          Object.assign(output, { [key]: obj2[key] });
        else
          output[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        Object.assign(output, { [key]: obj2[key] });
      }
    });
  }
  return output;
}

function useProductSearch() {
  const { apiInstance } = useShopwareContext();
  const search = async (productId, options) => {
    const associations = deepMerge(
      options?.withCmsAssociations ? cmsAssociations : {},
      options?.criteria
    );
    const result = await getProduct(productId, associations, apiInstance);
    return result;
  };
  return {
    search
  };
}

const shippingMethodsAssociations = {
  associations: {
    prices: {}
  }
};
function useCheckout() {
  const { apiInstance } = useShopwareContext();
  const { refreshCart } = useCart();
  const {
    sessionContext,
    selectedPaymentMethod,
    selectedShippingMethod,
    setShippingMethod,
    setPaymentMethod
  } = useSessionContext();
  const storeShippingMethods = inject("swShippingMethods", ref());
  provide("swShippingMethods", storeShippingMethods);
  const storePaymentMethods = inject("swPaymentMethods", ref());
  provide("swPaymentMethods", storePaymentMethods);
  const shippingMethods = computed(() => storeShippingMethods.value || []);
  const paymentMethods = computed(() => storePaymentMethods.value || []);
  async function getShippingMethods({ forceReload } = { forceReload: false }, associations = {}) {
    if (shippingMethods.value.length && !forceReload)
      return shippingMethods;
    const mergedAssociations = deepMerge(
      shippingMethodsAssociations,
      associations
    );
    const response = await getAvailableShippingMethods(apiInstance, {
      ...mergedAssociations
    });
    storeShippingMethods.value = response?.elements || [];
    return shippingMethods;
  }
  async function getPaymentMethods({ forceReload } = { forceReload: false }) {
    if (paymentMethods.value.length && !forceReload)
      return paymentMethods;
    const response = await getAvailablePaymentMethods(apiInstance, {
      onlyAvailable: true
      // depending on the context, some of them can be hidden due to applied rules describing whether a method can be available
    });
    storePaymentMethods.value = response?.elements || [];
    return paymentMethods;
  }
  async function createOrder$1(params) {
    try {
      const order = await createOrder(params, apiInstance);
      return order;
    } catch (e) {
      const err = e;
      throw err;
    } finally {
      refreshCart();
    }
  }
  const shippingAddress = computed(
    () => sessionContext.value?.shippingLocation?.address
  );
  const billingAddress = computed(
    () => sessionContext.value?.customer?.activeBillingAddress
  );
  return {
    getPaymentMethods,
    paymentMethods,
    getShippingMethods,
    shippingMethods,
    createOrder: createOrder$1,
    shippingAddress,
    billingAddress,
    selectedShippingMethod,
    setShippingMethod,
    selectedPaymentMethod,
    setPaymentMethod
  };
}

function useSalutations() {
  const { apiInstance } = useShopwareContext();
  const _salutations = inject("swSalutations", ref());
  provide("swSalutations", _salutations);
  const error = ref(null);
  const fetchSalutations = async () => {
    try {
      const { elements } = await getAvailableSalutations(apiInstance);
      _salutations.value = elements;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  };
  const mountedCallback = async () => {
    if (!_salutations.value) {
      await fetchSalutations();
    }
  };
  const getSalutations = computed(() => {
    return _salutations.value || [];
  });
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchSalutations,
    getSalutations
  };
}

function useCountries() {
  const { apiInstance } = useShopwareContext();
  const _sharedCountried = inject("swCountries", ref());
  provide("swCountries", _sharedCountried);
  async function fetchCountries() {
    const { elements } = await getAvailableCountries(apiInstance);
    _sharedCountried.value = elements;
  }
  const getCountries = computed(() => {
    return _sharedCountried.value ?? [];
  });
  const mountedCallback = async () => {
    if (!_sharedCountried.value) {
      await fetchCountries();
    }
  };
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchCountries,
    getCountries
  };
}

const orderAssociations = {
  associations: {
    lineItems: {
      associations: {
        cover: {},
        downloads: {
          associations: {
            media: {}
          }
        }
      }
    },
    addresses: {},
    deliveries: {
      associations: {
        shippingMethod: {}
      }
    },
    transactions: {
      associations: {
        paymentMethod: {}
      },
      sort: "-createdAt"
    }
  }
};
function useOrderDetails(orderId, associations) {
  const { apiInstance } = useShopwareContext();
  const _sharedOrder = inject("swOrderDetails", ref());
  provide("swOrderDetails", _sharedOrder);
  const paymentMethod = computed(
    () => _sharedOrder.value?.transactions?.[0]?.paymentMethod
  );
  const shippingMethod = computed(
    () => _sharedOrder.value?.deliveries?.[0]?.shippingMethod
  );
  const paymentUrl = ref();
  const personalDetails = computed(() => ({
    email: _sharedOrder.value?.orderCustomer?.email,
    firstName: _sharedOrder.value?.orderCustomer?.firstName,
    lastName: _sharedOrder.value?.orderCustomer?.lastName
  }));
  const billingAddress = computed(
    () => _sharedOrder.value?.addresses?.find(
      ({ id }) => id === _sharedOrder.value.billingAddressId
    )
  );
  const shippingAddress = computed(
    () => _sharedOrder.value?.deliveries?.[0]?.shippingOrderAddress
  );
  const shippingCosts = computed(() => _sharedOrder.value?.shippingTotal);
  const subtotal = computed(() => _sharedOrder.value?.price?.positionPrice);
  const total = computed(() => _sharedOrder.value?.price?.totalPrice);
  const status = computed(() => _sharedOrder.value?.stateMachineState?.name);
  async function loadOrderDetails() {
    const orderDetailsResponse = await getOrderDetails(
      orderId,
      deepMerge(orderAssociations, associations ? associations : {}),
      apiInstance
    );
    _sharedOrder.value = orderDetailsResponse ?? null;
  }
  async function handlePayment$1(finishUrl, errorUrl, paymentDetails) {
    const resp = await handlePayment(
      {
        orderId,
        finishUrl,
        errorUrl,
        paymentDetails
      },
      apiInstance
    );
    paymentUrl.value = resp?.redirectUrl;
  }
  async function cancel() {
    await cancelOrder(orderId, apiInstance);
    await loadOrderDetails();
  }
  async function changePaymentMethod(paymentMethodId) {
    await changeOrderPaymentMethod(orderId, paymentMethodId, apiInstance);
    await loadOrderDetails();
  }
  async function getMediaFile(downloadId) {
    const response = await getOrderDownloads(
      {
        orderId,
        downloadId
      },
      apiInstance
    );
    return response;
  }
  async function getDocumentFile(documentId, deepLinkCode) {
    const response = await getDocumentDownload(
      {
        documentId,
        deepLinkCode
      },
      apiInstance
    );
    return response;
  }
  const hasDocuments = computed(() => !!_sharedOrder.value.documents.length);
  const documents = computed(() => _sharedOrder.value.documents);
  return {
    order: computed(() => _sharedOrder.value),
    status,
    total,
    subtotal,
    shippingCosts,
    shippingAddress,
    billingAddress,
    personalDetails,
    paymentUrl,
    shippingMethod,
    paymentMethod,
    hasDocuments,
    documents,
    loadOrderDetails,
    handlePayment: handlePayment$1,
    cancel,
    changePaymentMethod,
    getMediaFile,
    getDocumentFile
  };
}

function useOrderPayment(order) {
  const { apiInstance } = useShopwareContext();
  const activeTransaction = computed(
    () => order.value?.transactions?.find((t) => t.paymentMethod?.active === true)
  );
  const paymentMethod = computed(() => activeTransaction.value?.paymentMethod);
  const paymentUrl = ref();
  const state = computed(() => activeTransaction.value?.stateMachineState);
  const isAsynchronous = computed(
    () => activeTransaction.value?.paymentMethod?.asynchronous && activeTransaction.value?.paymentMethod?.afterOrderEnabled
  );
  async function handlePayment$1(finishUrl, errorUrl, paymentDetails) {
    if (!order.value) {
      return;
    }
    const resp = await handlePayment(
      {
        orderId: order.value?.id,
        finishUrl,
        errorUrl,
        paymentDetails
      },
      apiInstance
    );
    paymentUrl.value = resp?.redirectUrl;
    return resp;
  }
  async function changePaymentMethod(paymentMethodId) {
    if (!order.value) {
      return;
    }
    changeOrderPaymentMethod(order.value?.id, paymentMethodId, apiInstance);
  }
  return {
    isAsynchronous,
    activeTransaction,
    state,
    paymentUrl,
    paymentMethod,
    handlePayment: handlePayment$1,
    changePaymentMethod
  };
}

const _wishlistItems$1 = ref([]);
function useLocalWishlist() {
  const updateStorage = () => {
    localStorage.setItem(
      "sw-wishlist-items",
      JSON.stringify(_wishlistItems$1.value)
    );
  };
  const getFromStorage = () => {
    if (typeof window != "undefined" && localStorage) {
      return JSON.parse(localStorage.getItem("sw-wishlist-items") ?? "[]");
    }
  };
  async function removeFromWishlist(id) {
    _wishlistItems$1.value = _wishlistItems$1.value?.filter(
      (itemId) => itemId != id
    );
    updateStorage();
  }
  async function addToWishlist(id) {
    if (!_wishlistItems$1.value.includes(id)) {
      _wishlistItems$1.value.push(id);
      updateStorage();
    }
  }
  async function clearWishlist() {
    _wishlistItems$1.value = [];
    updateStorage();
  }
  function getWishlistProducts() {
    const currentWishlist = getFromStorage();
    if (Array.isArray(currentWishlist) && currentWishlist.length) {
      _wishlistItems$1.value = currentWishlist;
    }
  }
  const items = computed(() => _wishlistItems$1.value);
  const count = computed(() => items.value.length);
  return {
    getWishlistProducts,
    addToWishlist,
    removeFromWishlist,
    clearWishlist,
    items,
    count
  };
}

const _wishlistItems = ref([]);
function useSyncWishlist() {
  const { apiInstance } = useShopwareContext();
  async function addToWishlistSync(id) {
    await addWishlistProduct(id, apiInstance);
    getWishlistProducts$1();
  }
  async function removeFromWishlistSync(id) {
    await removeWishlistProduct(id, apiInstance);
    getWishlistProducts$1();
  }
  async function getWishlistProducts$1() {
    const response = await getWishlistProducts(void 0, apiInstance);
    _wishlistItems.value = [
      ...response.products.elements.map((element) => element.id)
    ];
  }
  async function mergeWishlistProducts$1(itemsToMerge) {
    await mergeWishlistProducts(itemsToMerge, apiInstance);
  }
  const items = computed(() => _wishlistItems.value);
  const count = computed(() => items.value.length);
  return {
    getWishlistProducts: getWishlistProducts$1,
    addToWishlistSync,
    removeFromWishlistSync,
    mergeWishlistProducts: mergeWishlistProducts$1,
    items,
    count
  };
}

function useProductSearchSuggest() {
  const searchTerm = ref("");
  const listingComposable = useListing({
    listingType: "productSearchListing"
  });
  const search = async (additionalCriteria = {}) => {
    const searchCriteria = {
      query: searchTerm.value,
      ...additionalCriteria
    };
    return listingComposable.search(searchCriteria, {
      preventRouteChange: true
    });
  };
  return {
    searchTerm,
    loading: listingComposable.loading,
    search,
    loadMore: listingComposable.loadMore,
    getProducts: listingComposable.getElements,
    getTotal: listingComposable.getTotal
  };
}

function useCustomerPassword() {
  const { apiInstance } = useShopwareContext();
  const errors = reactive({
    resetPassword: [],
    updatePassword: []
  });
  async function updatePassword$1(updatePasswordData) {
    try {
      errors.updatePassword = [];
      await updatePassword(updatePasswordData, apiInstance);
    } catch (e) {
      errors.updatePassword = e.messages;
      return false;
    }
    return true;
  }
  async function resetPassword$1(resetPasswordData) {
    try {
      await resetPassword(resetPasswordData, apiInstance);
    } catch (e) {
      errors.resetPassword = e.messages;
      return false;
    }
    return true;
  }
  return {
    updatePassword: updatePassword$1,
    resetPassword: resetPassword$1,
    errors
  };
}

function useCustomerOrders() {
  const { apiInstance } = useShopwareContext();
  const orders = ref([]);
  const loadOrders = async (parameters = {}) => {
    const fetchedOrders = await getCustomerOrders(parameters, apiInstance);
    orders.value = fetchedOrders?.elements;
  };
  const changeCurrentPage = async (pageNumber) => await loadOrders({ page: +pageNumber });
  return {
    orders,
    changeCurrentPage,
    loadOrders
  };
}

function createShopwareContext(app, options) {
  const scope = effectScope(true);
  const state = scope.run(() => {
    return reactive({
      interceptors: {}
      // sharedStore: options.initialStore || reactive({}),
      // shopwareDefaults: options.shopwareDefaults || {},
    });
  });
  const shopwarePlugin = markRaw({
    install(app2, options2) {
      shopwarePlugin._a = app2;
      app2.config.globalProperties.$shopware = shopwarePlugin;
      app2.provide("shopware", shopwarePlugin);
      if (options2?.enableDevtools && typeof window !== "undefined") ;
    },
    _a: app,
    _e: scope,
    apiInstance: options.apiInstance,
    state
  });
  if (options?.enableDevtools && typeof window !== "undefined") ;
  return shopwarePlugin;
}

function useAddress() {
  const { apiInstance } = useShopwareContext();
  useUser();
  const _storeCustomerAddresses = inject(
    "swCustomerAddresses",
    ref([])
  );
  provide("swCustomerAddresses", _storeCustomerAddresses);
  async function loadCustomerAddresses(parameters = {}) {
    const { elements } = await getCustomerAddresses(parameters, apiInstance);
    _storeCustomerAddresses.value = elements;
  }
  async function createCustomerAddress$1(customerAddress) {
    const result = await createCustomerAddress(customerAddress, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function updateCustomerAddress$1(customerAddress) {
    const result = await updateCustomerAddress(customerAddress, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function deleteCustomerAddress$1(addressId) {
    const result = deleteCustomerAddress(addressId, apiInstance);
    await loadCustomerAddresses();
    return result;
  }
  async function setDefaultCustomerBillingAddress$1(addressId) {
    return await setDefaultCustomerBillingAddress(addressId, apiInstance);
  }
  async function setDefaultCustomerShippingAddress$1(addressId) {
    return await setDefaultCustomerShippingAddress(addressId, apiInstance);
  }
  return {
    customerAddresses: computed(() => _storeCustomerAddresses.value || []),
    loadCustomerAddresses,
    createCustomerAddress: createCustomerAddress$1,
    updateCustomerAddress: updateCustomerAddress$1,
    deleteCustomerAddress: deleteCustomerAddress$1,
    setDefaultCustomerBillingAddress: setDefaultCustomerBillingAddress$1,
    setDefaultCustomerShippingAddress: setDefaultCustomerShippingAddress$1
  };
}

function useProductPrice(product) {
  const _cheapest = computed(
    () => product.value?.calculatedCheapestPrice
  );
  const _real = computed(
    () => product.value?.calculatedPrices?.length > 0 ? product.value?.calculatedPrices[0] : product.value?.calculatedPrice
  );
  const referencePrice = computed(
    () => _real?.value?.referencePrice
  );
  const _displayParent = computed(
    () => product.value?.variantListingConfig?.displayParent && product.value?.parentId === null
  );
  const displayFrom = computed(
    () => product.value?.calculatedPrices?.length > 1 || !!(_displayParent.value && displayFromVariants.value)
  );
  const displayFromVariants = computed(
    () => !!product.value.parentId && product.value?.cheapestPrice?.hasRange && !!product.value?.cheapestPrice?.parentId && _real?.value?.unitPrice !== _cheapest?.value?.unitPrice && _cheapest?.value?.unitPrice
  );
  const _price = computed(() => {
    if (displayFrom.value && getProductTierPrices(product.value).length > 1) {
      const lowest = product.value?.calculatedPrices.reduce(
        (previous, current) => {
          return current.unitPrice < previous.unitPrice ? current : previous;
        }
      );
      return lowest || _cheapest.value;
    }
    return _real.value;
  });
  const unitPrice = computed(
    () => _price.value?.unitPrice
  );
  const totalPrice = computed(
    () => _price.value?.totalPrice
  );
  const price = computed(
    () => _price.value
  );
  const isListPrice = computed(
    () => !!_price.value?.listPrice?.percentage
  );
  const tierPrices = computed(() => getProductTierPrices(product.value));
  return {
    price,
    totalPrice,
    unitPrice,
    displayFromVariants,
    displayFrom,
    tierPrices,
    referencePrice,
    isListPrice
  };
}

function useInternationalization() {
  const { apiInstance } = useShopwareContext();
  function getStorefrontUrl() {
    return apiInstance.config.endpoint ?? window.location.origin ?? "";
  }
  return {
    getStorefrontUrl
  };
}

function useCmsMeta(entity) {
  const meta = computed(() => {
    const entries = [];
    const keywords = getTranslatedProperty(entity, "keywords");
    const description = getTranslatedProperty(entity, "metaDescription");
    const title = getTranslatedProperty(entity, "metaTitle");
    if (keywords) {
      entries.push({ name: "keywords", content: keywords });
    }
    if (description) {
      entries.push({ name: "description", content: description });
    }
    if (title) {
      entries.push({ name: "title", content: title });
    }
    return entries;
  });
  return {
    title: computed(() => getTranslatedProperty(entity, "name")),
    meta
  };
}

function useNewsletter() {
  const { apiInstance } = useShopwareContext();
  const { getStorefrontUrl } = useInternationalization();
  const newsletterStatus = ref(
    "undefined" /* UNDEFINED */
  );
  async function newsletterSubscribe$1(params) {
    return await newsletterSubscribe(
      {
        ...params,
        storefrontUrl: getStorefrontUrl()
      },
      apiInstance
    );
  }
  async function newsletterUnsubscribe$1(email) {
    return await newsletterUnsubscribe(
      {
        email
      },
      apiInstance
    );
  }
  async function getNewsletterStatus() {
    try {
      const response = await isNewsletterSubscriber(apiInstance);
      newsletterStatus.value = response.status;
    } catch (error) {
      console.error(error);
    }
  }
  const isNewsletterSubscriber$1 = computed(
    () => !["optOut" /* OPT_OUT */, "undefined" /* UNDEFINED */].includes(
      newsletterStatus.value
    )
  );
  const confirmationNeeded = computed(
    () => newsletterStatus.value === "notSet" /* NOT_SET */
  );
  return {
    newsletterSubscribe: newsletterSubscribe$1,
    newsletterUnsubscribe: newsletterUnsubscribe$1,
    isNewsletterSubscriber: isNewsletterSubscriber$1,
    getNewsletterStatus,
    newsletterStatus,
    confirmationNeeded
  };
}

function useNavigationContext(context) {
  const _context = _useContext("navigation", { context });
  const routeName = computed(() => _context.value?.routeName);
  const foreignKey = computed(() => _context.value?.foreignKey || "");
  return {
    navigationContext: computed(() => _context.value),
    routeName,
    foreignKey
  };
}

function useNavigationSearch() {
  const { apiInstance } = useShopwareContext();
  const { sessionContext } = useSessionContext();
  async function resolvePath(path) {
    if (path === "/") {
      const categoryId = sessionContext.value?.salesChannel?.navigationCategoryId;
      return {
        routeName: "frontend.navigation.page",
        foreignKey: categoryId
      };
    }
    const isTechnicalUrl = path.startsWith("/navigation/") || path.startsWith("/detail/") || path.startsWith("/landingPage/");
    const normalizedPath = isTechnicalUrl ? path : path.substring(1);
    const seoResult = await getSeoUrl(
      {
        filter: [
          {
            type: "equals",
            field: isTechnicalUrl ? "pathInfo" : "seoPathInfo",
            value: normalizedPath
          }
        ]
      },
      apiInstance
    );
    return seoResult.elements?.[0];
  }
  return {
    resolvePath
  };
}

function useWishlist() {
  const { isLoggedIn, isGuestSession } = useUser();
  const canSyncWishlist = computed(
    () => isLoggedIn.value && !isGuestSession.value
  );
  const {
    getWishlistProducts: getWishlistProductsLocal,
    items: itemsLocal,
    clearWishlist: clearWishlistLocal
  } = useLocalWishlist();
  const {
    getWishlistProducts: getWishlistProductsSync,
    items: itemsSync,
    mergeWishlistProducts: mergeWishlistProductsSync
  } = useSyncWishlist();
  const getWishlistProducts = async () => {
    if (canSyncWishlist.value) {
      await getWishlistProductsSync();
    } else {
      await getWishlistProductsLocal();
    }
  };
  const clearWishlist = () => {
    clearWishlistLocal();
  };
  const mergeWishlistProducts = async () => {
    if (itemsLocal.value?.length) {
      await mergeWishlistProductsSync(itemsLocal.value);
      clearWishlist();
    }
    getWishlistProductsSync();
  };
  const items = computed(
    () => canSyncWishlist.value ? itemsSync.value : itemsLocal.value
  );
  const count = computed(() => items.value.length);
  return {
    mergeWishlistProducts,
    getWishlistProducts,
    clearWishlist,
    items,
    count
  };
}

function useProductWishlist(product) {
  const { isLoggedIn } = useUser();
  const {
    addToWishlist: addItem,
    removeFromWishlist: removeItem,
    items
  } = useLocalWishlist();
  const {
    addToWishlistSync: addItemSync,
    removeFromWishlistSync: removeItemSync,
    items: itemsSync
  } = useSyncWishlist();
  async function removeFromWishlist() {
    if (isLoggedIn.value) {
      await removeItemSync(product.value.id);
    } else {
      await removeItem(product.value.id);
    }
  }
  async function addToWishlist() {
    if (isLoggedIn.value) {
      await addItemSync(product.value.id);
    } else {
      await addItem(product.value.id);
    }
  }
  const isInWishlist = computed(
    () => isLoggedIn.value ? itemsSync.value?.includes(product.value.id) : items.value?.includes(product.value.id)
  );
  return {
    addToWishlist,
    removeFromWishlist,
    isInWishlist
  };
}

function useBreadcrumbs(newBreadcrumbs) {
  const _breadcrumbs = _useContext("swBreadcrumb", {
    replace: newBreadcrumbs
  });
  const clearBreadcrumbs = () => {
    _breadcrumbs.value = [];
  };
  return {
    clearBreadcrumbs,
    breadcrumbs: computed(() => _breadcrumbs.value)
  };
}

function resolveCmsComponent(content) {
  const componentName = content.type;
  const type = content.apiAlias === "cms_block" ? "Block" : content.apiAlias === "cms_section" ? "Section" : "Element";
  const componentNameToResolve = pascalCase(`Cms-${type}-${componentName}`);
  try {
    const resolvedComponent = resolveComponent(componentNameToResolve);
    return {
      componentName,
      isResolved: resolvedComponent !== componentName,
      resolvedComponent: typeof resolvedComponent !== "string" ? resolvedComponent : void 0
    };
  } catch (e) {
    return {
      componentName,
      resolvedComponent: void 0,
      resolved: false,
      error: e.message
    };
  }
}
function getDefaultApiParams() {
  return {};
}

export { CATEGORY_ROUTE_NAME, LANDING_PAGE_ROUTE_NAME, PRODUCT_ROUTE_NAME, createListingComposable, createShopwareContext, getDefaultApiParams, resolveCmsComponent, useAddToCart, useAddress, useBreadcrumbs, useCart, useCartFunction, useCartItem, useCategory, useCategorySearch, useCheckout, useCmsBlock, useCmsElementConfig, useCmsElementImage, useCmsMeta, useCmsSection, useCountries, useCustomerOrders, useCustomerPassword, useInternationalization, useLandingSearch, useListing, useLocalWishlist, useNavigation, useNavigationContext, useNavigationSearch, useNewsletter, useNotifications, useOrderDetails, useOrderPayment, usePrice, useProduct, useProductAssociations, useProductConfigurator, useProductPrice, useProductReviews, useProductSearch, useProductSearchSuggest, useProductWishlist, useSalutations, useSessionContext, useShopwareContext, useSyncWishlist, useUser, useWishlist };
